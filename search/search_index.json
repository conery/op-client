{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Web App for OptiPass\u2122 The Migratory Fish Passage Optimization Tool (OptiPass), is an application developed by Jesse O'Hanley at Ecotelligence\u00ae LLC . The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed a REST server named op-server that runs on a Windows VM and acts as an abstract interface to OptiPass . op-client is a web application the provides a graphical user interface to op-server . It can be set up to run on any Linux, macOS, or Windows host. A user just has to start a web browser and point it to the client. Running OptiPass is simply a matter of setting optimization parameters using familar GUI elements like buttons and sliders and then clicking a \"run\" button. Outputs are display in charts and tables in the browser, and can be downloaded for later use offline. Demo The screenshot below shows the graphical user interface. In this example, the client has connected to a server and requested data from the \"demo\" project. This is a small data set from the OptiPass User Manual. It has six tide gates, named A through F. B and C are on the Red Fork river, the rest are on the Trident River. The example in the User Manual does not give names to the rivers. The names and map shown here are from an imaginary territory. We gave the rivers names in order to show how the GUI works. To set up an optimazation run, the user clicks next to river names, which shows the locations of the gates on the map. In this screenshot both rivers are selected so all six gates are highlighted. The user then chooses budget levels. In this case, OptiPass will run five times, with budgets ranging from $100,000 to $500,000. The last step is to choose optimization targets. In this case the user has decided target T1 should be given three times as much weight as T2. When the Run Optimizer button is clicked the client sends these settings to a remote server that is running the op-server software. That will be a Windows system that has OptiPass installed. After OptiPass has completed all five optimizations the results are collected and sent back to the client. The client presents the results as a set of ROI (return-on-investment) curves: Below the graphs are tables that show details of the optimization calculation: Deployment Scenarios There are three ways to set up a client. Each approach is outlined briefly here. Below that is a discussion of the pros and cons of each approach. If you decide you want to use on of the methods to set up your own client you can find detailed instructions in the Deployment section. Option 1: Install Locally The first option is to install the code on your own computer. This process if very similar to the steps used to install Jupyter and use it to edit IPython notebooks. The op-client software is written in Python and uses a library named Panel to display the graphical user interface. Once installed, open a terminal window and type a command that runs the Python program. Python creates a small special-purpose web server (named Bokeh), then you open a browser on your system and connect to the Bokeh server. Option 2: Docker Container This option is similar to Option 1, in that the client software will run on your computer. The difference is that you do not install any Python code. Instead, download (\"pull\") a Docker image from DockerHub. It will have all the code preinstalled in a self-contained Linux system. Then all you need to do is launch a container based on this image. A Bokeh server will be running inside the container. To use the client open a web browser and connect to the server. Option 3: Container at a Cloud Service This option is just like Option 2, except now the container is running at Amazon Web Services (AWS) or some other cloud computing environment. Setting up a new server based on a Docker image is very straightforward. For example, AWS has a service called Lightsail. You simply log in, choose some settings based on the level of service you want (based on how much traffic you expect), give it the name of the Docker image, and AWS does the rest. You can also associate a domain name with your new container so that other users can connect to your client. For example, if you own the domain tidegates-r-us.org you can set it up so it refers to your service at AWS and then other users can point their browswers to https://tidegates-r-us.org . Comparing Scenarios Which scenario is best depends on who will be using the client and what their goals are. Software Developer If you want to download the software to see how it works and perhaps adapt it for your own use Option 1 is best. You probably already have Python installed and are familiar with installing libraries with Pip so installing op-client will be very straightforward. Data Scientist If you want to use the client yourself but don't expect to dig into the source code consider Option 1 or 2. If you have Docker on your system already then Option 2 is clearly the easiest approach. If you don't have Docker, consider installing it. Docker is widely used in data science and odds are you will encounter other projects that are distributed as Docker images. Installing Docker is straightforward. There is a little learning curve the first time you use it, but overall the process is not much more complicated than installing a new Python library. Project Administrator If you want to configure an OptiPass server with data for your project and an OptiPass client that will let other project members or stakeholders access the server then Option 3 is your best choice. You could try Option 1 or Option 2, but it would mean (a) setting up a server on a system within your organization that everyone can access and (b) either installing Python and the client software or Docker on every other group member's system. It may take some initial effort to create an account at AWS and work through the process of launching a new service but in the end it will be far easier for other group members.","title":"A Web App for OptiPass\u2122"},{"location":"#a-web-app-for-optipasstm","text":"The Migratory Fish Passage Optimization Tool (OptiPass), is an application developed by Jesse O'Hanley at Ecotelligence\u00ae LLC . The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed a REST server named op-server that runs on a Windows VM and acts as an abstract interface to OptiPass . op-client is a web application the provides a graphical user interface to op-server . It can be set up to run on any Linux, macOS, or Windows host. A user just has to start a web browser and point it to the client. Running OptiPass is simply a matter of setting optimization parameters using familar GUI elements like buttons and sliders and then clicking a \"run\" button. Outputs are display in charts and tables in the browser, and can be downloaded for later use offline.","title":"A Web App for OptiPass\u2122"},{"location":"#demo","text":"The screenshot below shows the graphical user interface. In this example, the client has connected to a server and requested data from the \"demo\" project. This is a small data set from the OptiPass User Manual. It has six tide gates, named A through F. B and C are on the Red Fork river, the rest are on the Trident River. The example in the User Manual does not give names to the rivers. The names and map shown here are from an imaginary territory. We gave the rivers names in order to show how the GUI works. To set up an optimazation run, the user clicks next to river names, which shows the locations of the gates on the map. In this screenshot both rivers are selected so all six gates are highlighted. The user then chooses budget levels. In this case, OptiPass will run five times, with budgets ranging from $100,000 to $500,000. The last step is to choose optimization targets. In this case the user has decided target T1 should be given three times as much weight as T2. When the Run Optimizer button is clicked the client sends these settings to a remote server that is running the op-server software. That will be a Windows system that has OptiPass installed. After OptiPass has completed all five optimizations the results are collected and sent back to the client. The client presents the results as a set of ROI (return-on-investment) curves: Below the graphs are tables that show details of the optimization calculation:","title":"Demo"},{"location":"#deployment-scenarios","text":"There are three ways to set up a client. Each approach is outlined briefly here. Below that is a discussion of the pros and cons of each approach. If you decide you want to use on of the methods to set up your own client you can find detailed instructions in the Deployment section.","title":"Deployment Scenarios"},{"location":"#option-1-install-locally","text":"The first option is to install the code on your own computer. This process if very similar to the steps used to install Jupyter and use it to edit IPython notebooks. The op-client software is written in Python and uses a library named Panel to display the graphical user interface. Once installed, open a terminal window and type a command that runs the Python program. Python creates a small special-purpose web server (named Bokeh), then you open a browser on your system and connect to the Bokeh server.","title":"Option 1: Install Locally"},{"location":"#option-2-docker-container","text":"This option is similar to Option 1, in that the client software will run on your computer. The difference is that you do not install any Python code. Instead, download (\"pull\") a Docker image from DockerHub. It will have all the code preinstalled in a self-contained Linux system. Then all you need to do is launch a container based on this image. A Bokeh server will be running inside the container. To use the client open a web browser and connect to the server.","title":"Option 2: Docker Container"},{"location":"#option-3-container-at-a-cloud-service","text":"This option is just like Option 2, except now the container is running at Amazon Web Services (AWS) or some other cloud computing environment. Setting up a new server based on a Docker image is very straightforward. For example, AWS has a service called Lightsail. You simply log in, choose some settings based on the level of service you want (based on how much traffic you expect), give it the name of the Docker image, and AWS does the rest. You can also associate a domain name with your new container so that other users can connect to your client. For example, if you own the domain tidegates-r-us.org you can set it up so it refers to your service at AWS and then other users can point their browswers to https://tidegates-r-us.org .","title":"Option 3: Container at a Cloud Service"},{"location":"#comparing-scenarios","text":"Which scenario is best depends on who will be using the client and what their goals are.","title":"Comparing Scenarios"},{"location":"#software-developer","text":"If you want to download the software to see how it works and perhaps adapt it for your own use Option 1 is best. You probably already have Python installed and are familiar with installing libraries with Pip so installing op-client will be very straightforward.","title":"Software Developer"},{"location":"#data-scientist","text":"If you want to use the client yourself but don't expect to dig into the source code consider Option 1 or 2. If you have Docker on your system already then Option 2 is clearly the easiest approach. If you don't have Docker, consider installing it. Docker is widely used in data science and odds are you will encounter other projects that are distributed as Docker images. Installing Docker is straightforward. There is a little learning curve the first time you use it, but overall the process is not much more complicated than installing a new Python library.","title":"Data Scientist"},{"location":"#project-administrator","text":"If you want to configure an OptiPass server with data for your project and an OptiPass client that will let other project members or stakeholders access the server then Option 3 is your best choice. You could try Option 1 or Option 2, but it would mean (a) setting up a server on a system within your organization that everyone can access and (b) either installing Python and the client software or Docker on every other group member's system. It may take some initial effort to create an account at AWS and work through the process of launching a new service but in the end it will be far easier for other group members.","title":"Project Administrator"},{"location":"deploy/","text":"Deploying a Client Local Installation Using Pip To run the op-client application on your own system you need Python version 3.11.1 or later. When you type the pip command that installs the code you will probably be downloading dozens of new libraries, including Panel (the GUI libarary), Bokeh (the server that manages the web application), Pandas (data science libarary that works with tabular data). We strongly advise creating a new Python environment and installing the client there. In the examples below, the shell prompt is preceded by (tgo) , which is the name of the Python environment used to make the examples. This environment is based on pyenv but Conda would work equally well. The second part of the prompt is the name of the directory where the command was entered. 1. Download the Source Code Open a terminal window and cd to a directory where you want to install the server. If you have the GitHub command line tools, type this command to download the source code from GitHub: (tgo) [myprojects] $ gh repo clone conery/op-server If you don't have gh on your system you can download the project archive from https://github.com/conery/op-client and unzip it in your project directory. 2. Install the Python Libraries At this point you should have a new folder named op-sever in your project directory. cd into that folder: (tgo) [myprojects] $ cd op-server Type this command to have Pip install all the libraries required by the client: (tgo) [op-server] $ pip install -r requirements.txt 3. Start the Client The shell command that starts the client has this general form: (tgo) [op-server] $ python src/main.py --server X --project P where X is the URL of an op-server that will run OptiPass and P is the name of one of the data sets managed by that server. For example, if there is a server running at tidegates-r-us.org the command to connect to the server and work with the demo data would be (tgo) [op-server] $ python src/main.py --server http://tidegates-r-us.org --project demo A couple of notes: Depending on how the server is set up you might need to use a secure connection, i.e. use https instead of http at the beginning of the URL. There may be additional \"path\" information at the end of the URL. For example, the web server at tidegates-r-us.org may have several other web sites, in which case the web site administators there will have assigned a \"path\" that needs to be appended to the URL. In that case, the URL would look something like this: --server http://tidegates-r-us.org/op where op is the path defined by the web administrators. 4. Connect to the Client At this point you will have a Bokeh server running on your computer. To use the client, start any web browser and have it connect to http://localhost:5006 . The localhost part of that URL means \"this computer\". If your web browser doesn't recognize that name try using http://127.0.0.1:5006 5. Shutting Down the Client When you're done: close the browser window go back to the terminal window where you typed the command to start the client and hit \u2303C (hold down the control key while typing C) You can also just close the terminal window if you won't be needing it any more Local Container with Docker Desktop Another way to run the op-client application on your own system is to run the code in a pre-configured \"image\" from DockerHub. A Docker image is a small, self-contained Linux system that has Python, the client application, and all the libraries it needs already installed and ready to go. 1. Pull the Image The first time you use the client you need to download the image from DockerHub (Docker refers to this as \"pulling\" the image). Open the Docker Desktop GUI. Click on \"Docker Hub\" in the panel on the left side of the window. In the search bar, type \"conery\", then look for conery/op-client and click on that. You should now see a page that has a short description of the image, and a button labeled \"Pull\" on the right side of the window. Click that button to download the image. 2. Start the Container Once you have the image you can start a \"container\" (the Docker term for a running image). Open Docker Desktop and click on Images in the panel on the left. You should see table with a row for the op-client image. In the column labeled \"Actions\" there is a right-facing triangle (designed to look like the \"play\" button on a music app). Click the play button and a window will pop up. Click the arrow next to \"Optional Settings\". Under \"Ports\" there is a box. Click in the box, where it says \"host port\", and type 5006. At the bottom of the window is a section labeled \"Environment Variables\". This is where you specify the URL of the op-server you want to connect to and the name of the data set you want to use. Click in the box that says \"Variable\" and type OP_SERVER (using all upper case). Next to it, click on \"Value\" and enter the URL of the server. For example, if your server is at tidegates-r-us.org you would enter http://tidegates-r-us.org (see the note below). Click the plus sign to the right of the box where you just entered the URL. A new pair of variable name and value boxes appear. Enter OP_PROJECT in the variable box and the name of the data set ( e.g. demo ) in the value box. Click the Run box to launch the client application running inside your new container. Notes: Depending on how the server is set up you might need to use a secure connection, i.e. use https instead of http at the beginning of the URL for the op-server . There may be additional \"path\" information at the end of the URL. For example, the web server at tidegates-r-us.org may have several other web sites, in which case the web site administators there will have assigned a \"path\" that needs to be appended to the URL. In that case, the URL would look something like http://tidegates-r-us.org/op . 3. Open a Browser Window To connect to the software running in the container start a browser and tell it to open http://localhost:5006 (if that doesn't work try http://127.0.0.1:5006 ). 4. Managing the Container When you're done you can close the browser window. Open the Docker Desktop window and click on Containers in the panel on the left. In the table row for your container, in the column named Actions, the \"play\" button has been turned into a \"pause\" button (a gray square). If you want to use the container again in the future click the pause button. After a few seconds (while Docker is shutting down the container) the button will again look like a play button. The next time you want to use it come back here to this window and click the play button. The container will resume where you left off -- just open a browser window and connect to http://localhost:5006 again. You don't need to re-enter the container settings. If you are done with the container click the trash can icon at the end of the line. This will delete the container, but not the image. You can always come back in the future and create a new container using the steps in section 2 above. Container in the Cloud Coming soon: instructions for setting up a server at AWS.","title":"Deploying a Client"},{"location":"deploy/#deploying-a-client","text":"","title":"Deploying a Client"},{"location":"deploy/#local-installation-using-pip","text":"To run the op-client application on your own system you need Python version 3.11.1 or later. When you type the pip command that installs the code you will probably be downloading dozens of new libraries, including Panel (the GUI libarary), Bokeh (the server that manages the web application), Pandas (data science libarary that works with tabular data). We strongly advise creating a new Python environment and installing the client there. In the examples below, the shell prompt is preceded by (tgo) , which is the name of the Python environment used to make the examples. This environment is based on pyenv but Conda would work equally well. The second part of the prompt is the name of the directory where the command was entered.","title":"Local Installation Using Pip"},{"location":"deploy/#1-download-the-source-code","text":"Open a terminal window and cd to a directory where you want to install the server. If you have the GitHub command line tools, type this command to download the source code from GitHub: (tgo) [myprojects] $ gh repo clone conery/op-server If you don't have gh on your system you can download the project archive from https://github.com/conery/op-client and unzip it in your project directory.","title":"1. Download the Source Code"},{"location":"deploy/#2-install-the-python-libraries","text":"At this point you should have a new folder named op-sever in your project directory. cd into that folder: (tgo) [myprojects] $ cd op-server Type this command to have Pip install all the libraries required by the client: (tgo) [op-server] $ pip install -r requirements.txt","title":"2. Install the Python Libraries"},{"location":"deploy/#3-start-the-client","text":"The shell command that starts the client has this general form: (tgo) [op-server] $ python src/main.py --server X --project P where X is the URL of an op-server that will run OptiPass and P is the name of one of the data sets managed by that server. For example, if there is a server running at tidegates-r-us.org the command to connect to the server and work with the demo data would be (tgo) [op-server] $ python src/main.py --server http://tidegates-r-us.org --project demo A couple of notes: Depending on how the server is set up you might need to use a secure connection, i.e. use https instead of http at the beginning of the URL. There may be additional \"path\" information at the end of the URL. For example, the web server at tidegates-r-us.org may have several other web sites, in which case the web site administators there will have assigned a \"path\" that needs to be appended to the URL. In that case, the URL would look something like this: --server http://tidegates-r-us.org/op where op is the path defined by the web administrators.","title":"3. Start the Client"},{"location":"deploy/#4-connect-to-the-client","text":"At this point you will have a Bokeh server running on your computer. To use the client, start any web browser and have it connect to http://localhost:5006 . The localhost part of that URL means \"this computer\". If your web browser doesn't recognize that name try using http://127.0.0.1:5006","title":"4. Connect to the Client"},{"location":"deploy/#5-shutting-down-the-client","text":"When you're done: close the browser window go back to the terminal window where you typed the command to start the client and hit \u2303C (hold down the control key while typing C) You can also just close the terminal window if you won't be needing it any more","title":"5. Shutting Down the Client"},{"location":"deploy/#local-container-with-docker-desktop","text":"Another way to run the op-client application on your own system is to run the code in a pre-configured \"image\" from DockerHub. A Docker image is a small, self-contained Linux system that has Python, the client application, and all the libraries it needs already installed and ready to go.","title":"Local Container with Docker Desktop"},{"location":"deploy/#1-pull-the-image","text":"The first time you use the client you need to download the image from DockerHub (Docker refers to this as \"pulling\" the image). Open the Docker Desktop GUI. Click on \"Docker Hub\" in the panel on the left side of the window. In the search bar, type \"conery\", then look for conery/op-client and click on that. You should now see a page that has a short description of the image, and a button labeled \"Pull\" on the right side of the window. Click that button to download the image.","title":"1. Pull the Image"},{"location":"deploy/#2-start-the-container","text":"Once you have the image you can start a \"container\" (the Docker term for a running image). Open Docker Desktop and click on Images in the panel on the left. You should see table with a row for the op-client image. In the column labeled \"Actions\" there is a right-facing triangle (designed to look like the \"play\" button on a music app). Click the play button and a window will pop up. Click the arrow next to \"Optional Settings\". Under \"Ports\" there is a box. Click in the box, where it says \"host port\", and type 5006. At the bottom of the window is a section labeled \"Environment Variables\". This is where you specify the URL of the op-server you want to connect to and the name of the data set you want to use. Click in the box that says \"Variable\" and type OP_SERVER (using all upper case). Next to it, click on \"Value\" and enter the URL of the server. For example, if your server is at tidegates-r-us.org you would enter http://tidegates-r-us.org (see the note below). Click the plus sign to the right of the box where you just entered the URL. A new pair of variable name and value boxes appear. Enter OP_PROJECT in the variable box and the name of the data set ( e.g. demo ) in the value box. Click the Run box to launch the client application running inside your new container. Notes: Depending on how the server is set up you might need to use a secure connection, i.e. use https instead of http at the beginning of the URL for the op-server . There may be additional \"path\" information at the end of the URL. For example, the web server at tidegates-r-us.org may have several other web sites, in which case the web site administators there will have assigned a \"path\" that needs to be appended to the URL. In that case, the URL would look something like http://tidegates-r-us.org/op .","title":"2. Start the Container"},{"location":"deploy/#3-open-a-browser-window","text":"To connect to the software running in the container start a browser and tell it to open http://localhost:5006 (if that doesn't work try http://127.0.0.1:5006 ).","title":"3. Open a Browser Window"},{"location":"deploy/#4-managing-the-container","text":"When you're done you can close the browser window. Open the Docker Desktop window and click on Containers in the panel on the left. In the table row for your container, in the column named Actions, the \"play\" button has been turned into a \"pause\" button (a gray square). If you want to use the container again in the future click the pause button. After a few seconds (while Docker is shutting down the container) the button will again look like a play button. The next time you want to use it come back here to this window and click the play button. The container will resume where you left off -- just open a browser window and connect to http://localhost:5006 again. You don't need to re-enter the container settings. If you are done with the container click the trash can icon at the end of the line. This will delete the container, but not the image. You can always come back in the future and create a new container using the steps in section 2 above.","title":"4. Managing the Container"},{"location":"deploy/#container-in-the-cloud","text":"Coming soon: instructions for setting up a server at AWS.","title":"Container in the Cloud"},{"location":"gui/","text":"GUI The Python syntax for defining a new class that is derived from an existing class uses a class statement. This is the statement that defines the RegionBox class: class RegionBox(pn.Column): ... pn.Column is an existing widget class, defined in the Panel library. That means our new RegionBox objects will be special types of columns that can be inserted into the GUI at some place. The code that is called to create a new object is a function named __init__ defined inside the class. The first argument to __init__ is always self , which is a reference to the object being built. Here is a simplified version of the __init__ function for the RegionBox class (the actual definition is shown below, in the documentation for RegionBox): class RegionBox(pn.Column): def __init__(self, project): self.boxes = { } for name in OP.region_names: box = pn.widgets.Checkbox(name=name, styles=box_styles, stylesheets=[box_style_sheet]) box.param.watch(self.cb, ['value']) self.boxes[name] = box When this function is called, it initializes a variable named boxes to be an empty dictionary. The for loop iterates over all the region names. It makes a Checkbox widget for each region and adds the box to the dictionary. The line in the middle of the loop that calls box.param.watch is where all the \"magic\" happens. This function call tells the GUI that whenever a checkbox is clicked it should call a function named cb that is also defined inside the RegionBox class. Here is a simplified version: def cb(self, event): r = event.obj.name if event.new: self.selected.add(r) else: self.selected.remove(r) The name cb is short for \"callback\", a common name for this type of function. The parameter named event has information about what the user just did. In this case, we want to get the name of the button (which will be one of the region names) and then update the set of selected regions. If the button was turned on we add the region name to the set, otherwise we remove it. TideGatesApp Bases: BootstrapTemplate The web application is based on the Bootstrap template provided by Panel. It displays a map (an instance of the TGMap class) in the sidebar. The main content area has a Tabs widget with five tabs: a welcome message, a help page, the main page (described below) and two tabs for displaying outputs. The application also displays several small help buttons next to the main widgets. Clicking one of these buttons brings up a floating window with information about the widget. The main tab (labeled \"Start\") displays the widgets that allow the user to specify optimization parameters: region names, budget levels, and restoration targets. It also has a Run button. When the user clicks this button the callback function makes sure the necessary parameters have been defined and then uses the template's modal dialog area. Clicking the \"OK\" button in that dialog invokes another callback, defined here, that runs the optimizer. Parameters: params \u2013 runtime options passed to the parent class constructor Source code in src/gui/app.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def __init__ ( self , ** params ): \"\"\" Initialize the application. Arguments: params: runtime options passed to the parent class constructor \"\"\" super ( TideGatesApp , self ) . __init__ ( ** params ) # self.project_menu = pn.widgets.Select(options=['Demo','Oregon'], width=150) # self.header.append(pn.Row( # pn.layout.HSpacer(), # self.project_menu # )) self . map = TGMap . init () self . map_pane = pn . Column ( pn . panel ( self . map . graphic ()) ) self . budget_box = BudgetBox () self . region_boxes = RegionBox ( self . map , self . budget_box ) self . target_boxes = TargetBox () self . optimize_button = pn . widgets . Button ( name = 'Run Optimizer' , stylesheets = [ button_style_sheet ]) self . info = InfoBox ( self , self . run_cb ) self . modal . append ( self . info ) self . map_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . map_help_button . on_click ( self . map_help_cb ) self . region_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . region_help_button . on_click ( self . region_help_cb ) self . budget_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . budget_help_button . on_click ( self . budget_help_cb ) self . target_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . target_help_button . on_click ( self . target_help_cb ) self . climate_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . climate_help_button . on_click ( self . climate_help_cb ) # self.tab_height = int(self.map.graphic().height * 1.05) self . tab_height = 900 welcome_tab = pn . Column ( self . section_head ( 'Welcome' ), pn . pane . HTML ( OP . fetch_html_file ( 'welcome.html' )), height = self . tab_height , scroll = True , ) help_tab = pn . Column ( self . section_head ( 'Instructions' ), pn . pane . HTML ( OP . fetch_html_file ( 'help.html' )), height = self . tab_height , scroll = True , ) start_tab = pn . Column ( self . section_head ( 'Geographic Regions' , self . region_help_button ), self . region_boxes , self . section_head ( 'Budgets' , self . budget_help_button ), self . budget_box , self . section_head ( 'Targets' , self . target_help_button ), self . target_boxes , self . optimize_button , ) output_tab = pn . Column ( self . section_head ( 'Nothing to See Yet' ), pn . pane . HTML ( '<p>After running the optimizer this tab will show the results.</p>' ) ) download_tab = pn . Column ( self . section_head ( 'Nothing to Download Yet' ), pn . pane . HTML ( '<p>After running the optimizer use this tab to save the results.</p>' ) ) self . tabs = pn . Tabs ( ( 'Home' , welcome_tab ), ( 'Help' , help_tab ), ( 'Start' , start_tab ), ( 'Output' , output_tab ), ( 'Download' , download_tab ), stylesheets = [ tab_style_sheet ], # tabs_location='left', # sizing_mode = 'fixed', # width=800, # height=700, ) self . sidebar . append ( pn . Row ( self . map_pane , self . map_help_button )) self . main . append ( self . tabs ) self . optimize_button . on_click ( self . validate_settings ) for r in DevOP . default_regions (): self . region_boxes . check ( r ) self . budget_box . set_value ( DevOP . default_budget ()) self . target_boxes . set_selection ( DevOP . default_targets ()) if DevOP . results_dir (): self . run_optimizer () self . tabs . active = OP . initial_tab section_head ( s , b = None ) Create an HTML header for one of the sections in the Start tab. Source code in src/gui/app.py 148 149 150 151 152 153 def section_head ( self , s , b = None ): \"\"\" Create an HTML header for one of the sections in the Start tab. \"\"\" header = pn . pane . HTML ( f '<h3> { s } </h3>' , styles = header_styles ) return header if b is None else pn . Row ( header , b ) validate_settings ( _ ) Callback function invoked when the user clicks the Run Optimizer button. Source code in src/gui/app.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def validate_settings ( self , _ ): \"\"\" Callback function invoked when the user clicks the Run Optimizer button. \"\"\" regions = self . region_boxes . selection () budget = self . budget_box . defined () targets = self . target_boxes . selection () if len ( regions ) == 0 or ( not budget ) or len ( targets ) == 0 : self . info . show_missing ( regions , budget , targets ) return if weights := self . target_boxes . weights (): if not all ([ w . isdigit () and ( 1 <= int ( w ) <= 5 ) for w in weights ]): self . info . show_invalid_weights ( weights ) return mapping = self . target_boxes . mapping () self . info . show_params ( regions , self . budget_box . values (), targets , weights , mapping ) run_cb ( _ ) Callback function invoked when the user clicks the Continue button after verifying the parameter options. Wrap the call to the function that runs the optimizer in code that shows the loading icon and opens a message when the function returns. Source code in src/gui/app.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def run_cb ( self , _ ): \"\"\" Callback function invoked when the user clicks the Continue button after verifying the parameter options. Wrap the call to the function that runs the optimizer in code that shows the loading icon and opens a message when the function returns. \"\"\" try : self . close_modal () self . main [ 0 ] . loading = True self . run_optimizer () self . main [ 0 ] . loading = False self . info . show_success () except OPServerError as err : self . main [ 0 ] . loading = False self . info . show_fail ( err ) run_optimizer () Use the settings in the widgets to run OptiPass, save the results in the output tab. Source code in src/gui/app.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def run_optimizer ( self ): \"\"\" Use the settings in the widgets to run OptiPass, save the results in the output tab. \"\"\" params = [ self . region_boxes . selection (), self . budget_box . values (), self . target_boxes . selection (), self . target_boxes . weights (), self . target_boxes . mapping (), ] resp = OP . run_optimizer ( * params ) params += resp res = OPResult ( * params ) output = OutputPane ( res , self . map ) self . region_boxes . add_external_callback ( output . hide_dots ) self . tabs [ 3 ] = ( 'Output' , pn . Column ( output , height = self . tab_height , scroll = True )) self . tabs [ 4 ] = ( 'Download' , pn . Column ( DownloadPane ( res ), height = self . tab_height , scroll = True )) map_help_cb ( _ ) Callback function for the help button next to the map in the sidebar. Source code in src/gui/app.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def map_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the map in the sidebar. \"\"\" msg = pn . pane . HTML ( ''' <p>When you move your mouse over the map the cursor will change to a \"crosshairs\" symbol and a set of buttons will appear below the map. Navigating with the map is similar to using Google maps or other online maps:</p> <ul> <li>Left-click and drag to pan (move left and right or up and down).</li> <li>If you want to zoom in and out, first click the magnifying glass button below the map; then you can zoom in and out using the scroll wheel on your mouse.</li> <li>Click the refresh button to restore the map to its original size and location.</li> </ul> ''' ) self . tabs [ 0 ] . append ( pn . layout . FloatPanel ( msg , name = 'Map Controls' , contained = False , position = 'center' , width = 400 )) region_help_cb ( _ ) Callback function for the help button next to the region box widget in the start tab. Source code in src/gui/app.py 232 233 234 235 236 237 238 239 240 241 def region_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the region box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>Select a region by clicking in the box to the left of an estuary name.</p> <p>Each time you click in a box the map will be updated to show the positions of the barriers that are in our database for the estuary.</p> <p>You must select at least one region before you run the optimizer.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Geographic Regions' , contained = False , position = 'center' , width = 400 )) budget_help_cb ( _ ) Callback function for the help button next to the budget box widget in the start tab. Source code in src/gui/app.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def budget_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the budget box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>There are three ways to specify the budgets used by the optimizer.</p> <H4>Basic</H4> <p>The simplest method is to specify an upper limit by moving the slider back and forth. When you use this method, the optimizer will run 10 times, ending at the value you select with the slider. For example, if you set the slider at $10M (the abbreviation for $10 million), the optimizer will make ROI curves based on budgets of $1M, $2M, <i>etc</i>, up to the maximum of $10M.</p> <p>Note that the slider is disabled until you select one or more regions. That's because the maximum value depends on the costs of the gates in each region. For example, the total cost of all gates in the Coquille region is $11.8M. Once you choose that region, you can move the budget slider left and right to pick a maximum budget for the optimizer to consider. <H4>Advanced</H4> <p>If you click on the Advanced tab in this section you will see ways to specify the budget interval and the number of budgets.</p> <p>You can use this method if you want more control over the layout of the ROI curves, for example you can include more points by increasing the number of budgets.</p> <H4>Fixed</H4> <p>If you know exactly how much money you have to spend you can enter that amount by clicking on the Fixed tab and entering the budget amount.</p> <p>The optimizer will run just once, using that budget. The output will have tables showing the gates identified by the optimizer, but there will be no ROI curve.</p> <p>When entering values, you can write the full amount, with or without commas (<i>e.g.</i>11,500,000 or 11500000) or use the abbreviated form (11.5M).</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Budget Levels' , contained = False , position = 'center' , width = 400 )) target_help_cb ( _ ) Callback function for the help button next to the target box widget in the start tab. Source code in src/gui/app.py 264 265 266 267 268 269 270 271 272 273 def target_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the target box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>Click boxes next to one or more target names to have the optimizer include those targets in its calculations.</p> <p>The optimizer will create an ROI curve for each target selected. </p> <p>If more than one target is selected the optimizer will also generate an overall \"net benefit\" curve based on considering all targets at the same time.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Targets' , contained = False , position = 'center' , width = 400 )) climate_help_cb ( _ ) Callback function for the help button next to the climate scenario checkbox in the start tab. Source code in src/gui/app.py 275 276 277 278 279 280 281 282 283 def climate_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the climate scenario checkbox in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>By default the optimizer uses current water levels when computing potential benefits. Click the button next to <b>Future</b> to have it use water levels expected due to climate change.</p> <p>The future scenario uses two projected water levels, both for the period to 2100. For fish habitat targets, the future water level is based on projected sea level rise of 5.0 feet. For agriculture and infrastructure targets, the future water level is projected to be 7.2 feet, which includes sea level rise and the probabilities of extreme water levels causing flooding events.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Targets' , contained = False , position = 'center' , width = 400 )) BudgetBox Bases: Column There are three ways users can specify the range of budget values when running OptiPass. A BudgetBox widget has one tab for each option. The widgets displayed inside a tab are defined by their own classes (BasicBudgetBox, AdvancedBudgetBox, and FixedBudgetBox). Source code in src/gui/budgets.py 19 20 21 22 23 24 25 26 def __init__ ( self ): super ( BudgetBox , self ) . __init__ () self . tabs = pn . Tabs ( ( 'Basic' , BasicBudgetBox ()), ( 'Advanced' , AdvancedBudgetBox ()), ( 'Fixed' , FixedBudgetBox ()), ) self . append ( self . tabs ) set_budget_max ( n ) When the user selects or deselects a region the budget widgets need to know the new total cost for all the selected regions. This method passes that information to each of the budget widgets. Parameters: n ( int ) \u2013 the new maximum budget amount Source code in src/gui/budgets.py 28 29 30 31 32 33 34 35 36 37 38 def set_budget_max ( self , n : int ): \"\"\" When the user selects or deselects a region the budget widgets need to know the new total cost for all the selected regions. This method passes that information to each of the budget widgets. Arguments: n: the new maximum budget amount \"\"\" for t in self . tabs : t . set_budget_max ( n ) values () Return the budget settings for the currently selected budget type. Get the widget values from the active budget type, convert them into a tuple of values that will be passed to the optimizer. Returns: bmin \u2013 the starting budget binc \u2013 the increment between budget values bcnt \u2013 the number of budget values Source code in src/gui/budgets.py 40 41 42 43 44 45 46 47 48 49 50 51 def values ( self ): \"\"\" Return the budget settings for the currently selected budget type. Get the widget values from the active budget type, convert them into a tuple of values that will be passed to the optimizer. Returns: bmin: the starting budget binc: the increment between budget values bcnt: the number of budget values \"\"\" return self . tabs [ self . tabs . active ] . values () defined () Return True if the user has defined a budget using the current tab Source code in src/gui/budgets.py 53 54 55 56 57 def defined ( self ): \"\"\" Return True if the user has defined a budget using the current tab \"\"\" return self . tabs [ self . tabs . active ] . defined () set_value ( n ) Initialize the GUI by setting an initial budget value Source code in src/gui/budgets.py 59 60 61 62 63 def set_value ( self , n ): \"\"\" Initialize the GUI by setting an initial budget value \"\"\" self . tabs [ self . tabs . active ] . set_value ( n ) BasicBudgetBox Bases: WidgetBox The default budget widget displays a slider that ranges from 0 up to a maximum value based on the total cost of all barriers in currently selected regions. Source code in src/gui/budgets.py 87 88 89 90 91 92 93 94 95 96 97 98 def __init__ ( self ): super ( BasicBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . labels = [ x [ 0 ] for x in self . levels ] self . map = { x [ 0 ]: x [ 1 ] for x in self . levels } self . slider = pn . widgets . DiscreteSlider ( options = self . labels [: self . MIN_LEVELS ], value = self . labels [ 0 ], name = 'Maximum Budget' , margin = ( 20 , 20 , 20 , 20 ), stylesheets = [ slider_style_sheet ], ) self . append ( self . slider ) set_budget_max ( n ) Choose a maximum budget by scanning a table of budget levels to find the first one less than the total cost. Parameters: n \u2013 the total cost of all barriers in the current selection. Source code in src/gui/budgets.py 100 101 102 103 104 105 106 107 108 109 110 111 112 def set_budget_max ( self , n ): \"\"\" Choose a maximum budget by scanning a table of budget levels to find the first one less than the total cost. Arguments: n: the total cost of all barriers in the current selection. \"\"\" for i in range ( len ( self . levels ) - 1 , - 1 , - 1 ): if n >= self . levels [ i ][ 1 ]: break i = max ( i , self . MIN_LEVELS ) self . slider . options = self . labels [: i + 1 ] values () The basic budget always has the same number of budgets and always starts with $0. Determine the increment by dividing the max budget in the slider by the number of budgets. Source code in src/gui/budgets.py 116 117 118 119 120 121 122 123 def values ( self ): \"\"\" The basic budget always has the same number of budgets and always starts with $0. Determine the increment by dividing the max budget in the slider by the number of budgets. \"\"\" x = self . map [ self . slider . value ] return 0 , x // self . BUDGET_COUNT , self . BUDGET_COUNT defined () The basic budget is set if the slider is not in the first location. Source code in src/gui/budgets.py 125 126 127 128 129 def defined ( self ): \"\"\" The basic budget is set if the slider is not in the first location. \"\"\" return self . slider . value != '$0' set_value ( n ) Set the slider to n Source code in src/gui/budgets.py 131 132 133 134 135 def set_value ( self , n ): \"\"\" Set the slider to n \"\"\" self . slider . value = self . slider . options [ n ] FixedBudgetBox Bases: WidgetBox This option is for situations where a user knows exactly how much money they have to spend and want to know the optimal set of barriers to replace for that amount of money. OptiPass is run twice -- once to determine the current passabilities, and once to compute the benefit from the specified budget. The widget simply displays a box where the user enters the dollar amount for their budget. Source code in src/gui/budgets.py 147 148 149 150 def __init__ ( self ): super ( FixedBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . input = pn . widgets . TextInput ( name = 'Budget Amount' , value = '$' ) self . append ( self . input ) values () A fixed budget has one value, returned as the starting budget. The the increment is 0 and count is 1. Source code in src/gui/budgets.py 155 156 157 158 159 160 161 162 163 164 def values ( self ): \"\"\" A fixed budget has one value, returned as the starting budget. The the increment is 0 and count is 1. \"\"\" s = self . input . value if s . startswith ( '$' ): s = s [ 1 :] n = self . parse_dollar_amount ( self . input . value ) return n , 0 , 1 defined () The fixed budget is set if the text box is not empty. Source code in src/gui/budgets.py 166 167 168 169 170 def defined ( self ): \"\"\" The fixed budget is set if the text box is not empty. \"\"\" return self . parse_dollar_amount ( self . input . value ) > 0 set_value ( n ) Initialize the budget to n Source code in src/gui/budgets.py 172 173 174 175 176 def set_value ( self , n ): \"\"\" Initialize the budget to n \"\"\" self . input . value = f '$ { n } ' parse_dollar_amount ( s ) Make sure the string entered by the user has an acceptable format. It can be all digits (e.g. \"1500000\"), or digits separated by commas (e.g. \"1,500,000\"), or a number followed by a K or M (e.g. \"1.5M\"). There can be a dollar sign at the front of the string. Parameters: s ( str ) \u2013 the string entered into the text box Returns: \u2013 the value of the string converted into an integer Source code in src/gui/budgets.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def parse_dollar_amount ( self , s : str ): \"\"\" Make sure the string entered by the user has an acceptable format. It can be all digits (e.g. \"1500000\"), or digits separated by commas (e.g. \"1,500,000\"), or a number followed by a K or M (e.g. \"1.5M\"). There can be a dollar sign at the front of the string. Arguments: s: the string entered into the text box Returns: the value of the string converted into an integer \"\"\" try : if s . startswith ( '$' ): s = s [ 1 :] if s . endswith (( 'K' , 'M' )): multiplier = 1000 if s . endswith ( 'K' ) else 1000000 res = int ( float ( s [: - 1 ]) * multiplier ) elif ',' in s : parts = s . split ( ',' ) assert len ( parts [ 0 ]) <= 3 and ( len ( parts ) == 1 or all ( len ( p ) == 3 for p in parts [ 1 :])) res = int ( '' . join ( parts )) else : res = 0 if s == '' else int ( s ) return res except Exception : return 0 AdvancedBudgetBox Bases: WidgetBox The \"advanced\" option gives the user the most control over the budget values processed by OptiPass by letting them specify the number of budget levels (in the basic budget there are always 10 budget levels). This box has three widgets: a slider to specify the maximum amount, another slider to specify the increment between budgets, and an input box to specify the number of budgets. Adjusting the value of any of these widgets automatically updates the other two. For example, if the maximum is set to $1M and the number of budgets is 10, the increment is $100K. If the user changes the number of budgets to 20, the increment drops to $50K. Or if they change the maximum to $2M, the increment increases to $200K. Source code in src/gui/budgets.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __init__ ( self ): super ( AdvancedBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 ), width = self . BOX_WIDTH ) self . cap = 0 self . max_slider = pn . widgets . FloatSlider ( name = 'Maximum Budget' , start = 0 , end = 1 , step = self . MAX_STEP , value = 0 , width = self . MAX_SLIDER_WIDTH , format = NumeralTickFormatter ( format = '$0,0' ), stylesheets = [ slider_style_sheet ], ) self . inc_slider = pn . widgets . FloatSlider ( name = 'Budget Interval' , start = 0 , end = 1 , step = self . INC_STEP , value = 0 , width = self . INC_SLIDER_WIDTH , format = NumeralTickFormatter ( format = '$0,0' ), stylesheets = [ slider_style_sheet ], ) self . count_input = pn . widgets . IntInput ( value = 10 , step = 1 , start = self . COUNT_MIN , end = self . COUNT_MAX , width = 75 , ) self . append ( pn . GridBox ( nrows = 2 , ncols = 2 , objects = [ self . max_slider , self . inc_slider , pn . pane . HTML ( '<b>Limit: N/A<b>' ), pn . Row ( pn . pane . HTML ( '#Budgets:' ), self . count_input , align = ( 'start' , 'center' )) ] )) self . max_slider . param . watch ( self . max_updated , [ 'value' ]) self . inc_slider . param . watch ( self . inc_updated , [ 'value' ]) self . count_input . param . watch ( self . count_updated , [ 'value' ]) values () In this widget the budget increment and budget count are determined by the values in the corresponding widgets. Source code in src/gui/budgets.py 281 282 283 284 285 286 def values ( self ): \"\"\" In this widget the budget increment and budget count are determined by the values in the corresponding widgets. \"\"\" return 0 , self . inc_slider . value , self . count_input . value defined () The advance budget is set if the increment is not 0 Source code in src/gui/budgets.py 288 289 290 291 292 def defined ( self ): \"\"\" The advance budget is set if the increment is not 0 \"\"\" return self . inc_slider . value > 0 set_value ( n ) Set the budget to n Source code in src/gui/budgets.py 294 295 296 297 298 def set_value ( self , n ): \"\"\" Set the budget to n \"\"\" self . max_slider . value = n set_budget_max ( n ) Called when the user selects or deselects a region. Save the new maximum, and update the value of the increment based on the new maximum. Parameters: n \u2013 the total cost of all barriers in the selected regions. Source code in src/gui/budgets.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def set_budget_max ( self , n ): \"\"\" Called when the user selects or deselects a region. Save the new maximum, and update the value of the increment based on the new maximum. Arguments: n: the total cost of all barriers in the selected regions. \"\"\" self . max_slider . end = max ( 1 , n ) self . max_slider . start = self . MAX_STEP self . inc_slider . end = max ( 1 , n // 2 ) self . inc_slider . start = max ( self . INC_STEP , n / self . COUNT_MAX ) lim = 'N/A' if n == 0 else f '$ { n / 1000000 : .2f } M' self . objects [ 0 ][ 2 ] = pn . pane . HTML ( f '<b>Limit: { lim } </b>' ) max_updated ( e ) Callback function invoked when the user moves the maximum budget slider. Computes a new budget increment. Source code in src/gui/budgets.py 315 316 317 318 319 320 321 322 323 def max_updated ( self , e ): \"\"\" Callback function invoked when the user moves the maximum budget slider. Computes a new budget increment. \"\"\" try : self . inc_slider . value = self . max_slider . value // self . count_input . value except ArithmeticError : pass inc_updated ( e ) Callback function invoked when the user changes the budget increment. Computes a new number of budgets. Source code in src/gui/budgets.py 325 326 327 328 329 330 331 332 333 334 335 def inc_updated ( self , e ): \"\"\" Callback function invoked when the user changes the budget increment. Computes a new number of budgets. \"\"\" try : c = max ( self . COUNT_MIN , self . max_slider . value // self . inc_slider . value ) c = min ( self . COUNT_MAX , c ) self . count_input . value = c except ArithmeticError : pass count_updated ( e ) Callback function invoked when the user changes the number of budget levels. Computes a new budget increment. Source code in src/gui/budgets.py 337 338 339 340 341 342 343 344 345 def count_updated ( self , e ): \"\"\" Callback function invoked when the user changes the number of budget levels. Computes a new budget increment. \"\"\" try : self . inc_slider . value = self . max_slider . value // self . count_input . value except ArithmeticError : pass DownloadPane Bases: Column After OptiPass has completed the last optimization run the GUI creates an instance of this class and saves it in the Download tab of the top level display. Check the output panel to see which plots were created and to enable the net benefit plot if there is one. The pane also has a form to allow the user to enter the name of the download file, the format for the figures, and a button to click when they are ready to download the data. Parameters: op \u2013 the OPResult object containing data tables and plots Source code in src/gui/output.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def __init__ ( self , op ): \"\"\" Display a set of checkboxes for the user to select what sort of data to include in a zip file. If the gate table is not empty enable table downloads. Check the output panel to see which plots were created and to enable the net benefit plot if there is one. The pane also has a form to allow the user to enter the name of the download file, the format for the figures, and a button to click when they are ready to download the data. Arguments: op: the OPResult object containing data tables and plots \"\"\" super ( DownloadPane , self ) . __init__ () self . op = op self . folder_name = self . _make_folder_name () self . grid = pn . GridBox ( ncols = 2 ) self . boxes = { } for x in [ self . NB , self . BS , self . IT , self . BD ]: b = pn . widgets . Checkbox ( name = x , styles = box_styles , stylesheets = [ box_style_sheet ]) if x in [ self . NB , self . IT ]: b . disabled = True b . value = False else : b . value = True self . boxes [ x ] = b self . grid . objects . append ( b ) self . filename_input = pn . widgets . TextInput ( name = '' , value = self . folder_name , ) self . image_type = pn . widgets . RadioBoxGroup ( name = 'IFF' , options = [ 'HTML' , 'PDF' , 'PNG' , 'JPEG' ], inline = True ) self . make_archive_button = pn . widgets . Button ( name = 'Create Output Folder' , stylesheets = [ button_style_sheet ]) self . make_archive_button . on_click ( self . _archive_cb ) self . append ( pn . pane . HTML ( '<h3>Save Outputs</h3>' , styles = header_styles )) if len ( self . op . matrix ) > 0 : self . append ( pn . pane . HTML ( '<b>Items to Include in the Output Folder:</b>' )), self . append ( self . grid ) self . append ( pn . Row ( pn . pane . HTML ( '<b>Image File Format:</b>' ), self . image_type , margin = ( 20 , 0 , 0 , 0 ), )) self . append ( pn . Row ( pn . pane . HTML ( '<b>Output Folder Name:</b>' ), self . filename_input , margin = ( 20 , 0 , 0 , 0 ), )) self . append ( self . make_archive_button ) self . append ( pn . pane . HTML ( '<p>placeholder</p>' , visible = False )) # if there are figures at least one of them is an individual target, so enable # that option; if there is a net benefit figure it's the first figure, enable it # if it's there if len ( self . op . display_figures ) > 0 : if self . op . display_figures [ 0 ][ 0 ] == 'Net' : self . boxes [ self . NB ] . value = True self . boxes [ self . NB ] . disabled = False self . boxes [ self . IT ] . value = True self . boxes [ self . IT ] . disabled = False _make_folder_name () Use the region names, target names, and budget range to create the default name of the zip file. Source code in src/gui/output.py 263 264 265 266 267 268 269 270 271 272 273 274 275 def _make_folder_name ( self ): \"\"\" Use the region names, target names, and budget range to create the default name of the zip file. \"\"\" parts = [ s [: 3 ] for s in self . op . regions ] lst = self . op . targets if self . op . weights : lst = [ f ' { lst [ i ] } x { self . op . weights [ i ] } ' for i in range ( len ( lst ))] parts . extend ( lst ) parts . append ( OP . format_budget_amount ( self . op . binc * self . op . bcount )[ 1 :]) if self . op . mapping : parts . append ( self . op . mapping ) return '_' . join ( parts ) _archive_cb ( e ) Function called when the user clicks the Download button. Create the output folder and compress it. When the archive is ready, display a FileDownload widget with a button that starts the download. Source code in src/gui/output.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def _archive_cb ( self , e ): \"\"\" Function called when the user clicks the Download button. Create the output folder and compress it. When the archive is ready, display a FileDownload widget with a button that starts the download. \"\"\" if not any ([ x . value for x in self . boxes . values ()]): return self . loading = True base = self . _make_archive_dir () self . _save_files ( base ) p = make_archive ( base , 'zip' , base ) self . loading = False self [ - 1 ] = pn . widgets . FileDownload ( file = p , filename = self . filename + '.zip' , stylesheets = [ button_style_sheet ]) _make_archive_dir () Create an empty directory for the download, using the name in the form. Source code in src/gui/output.py 292 293 294 295 296 297 298 299 300 301 def _make_archive_dir ( self ): \"\"\" Create an empty directory for the download, using the name in the form. \"\"\" self . filename = self . filename_input . value_input or self . filename_input . value archive_dir = Path . cwd () / 'tmp' / self . filename if Path . exists ( archive_dir ): rmtree ( archive_dir ) Path . mkdir ( archive_dir ) return archive_dir _save_files ( loc ) Write the tables and figures to the download directory. Parameters: loc \u2013 the path to the directory. Source code in src/gui/output.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def _save_files ( self , loc ): \"\"\" Write the tables and figures to the download directory. Arguments: loc: the path to the directory. \"\"\" figures = self . op . display_figures if self . image_type . value == 'HTML' else self . op . download_figures for name , fig in figures : if name == 'Net' and not self . boxes [ self . NB ] . value : continue if name != 'Net' and not self . boxes [ self . IT ] . value : continue if self . image_type . value == 'HTML' : savehtml ( fig , filename = loc / f ' { name } .html' ) else : ext = self . image_type . value . lower () fn = loc / f ' { name } . { ext } ' fig . savefig ( fn , bbox_inches = 'tight' ) if self . boxes [ self . BS ] . value : df = self . op . summary . drop ([ 'gates' ], axis = 1 ) df . to_csv ( loc / 'budget_summary.csv' , index = False , float_format = lambda n : round ( n , 2 ) ) if self . boxes [ self . BD ] . value : self . op . matrix . to_csv ( loc / 'barrier_details.csv' , index = False , float_format = lambda n : round ( n , 2 ) ) InfoBox Bases: Column When the user clicks the Run Optimizer button in the Start panel the GUI displays a message by calling one of the methods in this class. Messages are displayed in the modal dialog area defined by the GUI template. Parameters: template \u2013 the application template (which contains the modal dialog area to use) run_cb \u2013 a callback function to invoke after the user reviews settings and clicks \"Continue\" Source code in src/gui/infobox.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , template , run_cb ): \"\"\" Initialize the module. Arguments: template: the application template (which contains the modal dialog area to use) run_cb: a callback function to invoke after the user reviews settings and clicks \"Continue\" \"\"\" super ( InfoBox , self ) . __init__ () self . template = template self . continue_button = pn . widgets . Button ( name = 'Continue' ) self . continue_button . on_click ( run_cb ) self . cancel_button = pn . widgets . Button ( name = 'Cancel' ) self . cancel_button . on_click ( self . _cancel_cb ) _cancel_cb ( _ ) Close the dialog when the user clicks the \"Cancel\" button. Source code in src/gui/infobox.py 60 61 62 63 64 def _cancel_cb ( self , _ ): \"\"\" Close the dialog when the user clicks the \"Cancel\" button. \"\"\" self . template . close_modal () show_missing ( rlist , budget , tlist ) Method called by the OP class when it detects missing parameters (e.g. if the user did not select a region or a target). Source code in src/gui/infobox.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def show_missing ( self , rlist , budget , tlist ): \"\"\" Method called by the OP class when it detects missing parameters (e.g. if the user did not select a region or a target). \"\"\" text = self . missing_params_text if len ( rlist ) == 0 : text += ' * one or more geographic regions \\n ' if not budget : text += ' * a maximum budget \\n ' if len ( tlist ) == 0 : text += ' * one or more targets \\n ' self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'warning' )) self . template . open_modal () show_invalid_weights ( w ) Method called when weighted targets are being used and one of the text boxes does not have a valid entry (must be a number between 1 and 5). Parameters: w ( list [ str ] ) \u2013 the list of strings read from the text entry widgets Source code in src/gui/infobox.py 82 83 84 85 86 87 88 89 90 91 92 93 def show_invalid_weights ( self , w : list [ str ]): \"\"\" Method called when weighted targets are being used and one of the text boxes does not have a valid entry (must be a number between 1 and 5). Arguments: w: the list of strings read from the text entry widgets \"\"\" text = self . invalid_weights_text . format ( w ) self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'warning' )) self . template . open_modal () show_params ( regions , budgets , targets , weights , mapping ) Method called to allow the user to review the optimization parameters read from the various widgets. Displays each parameter and two buttons (\"Cancel\" and \"Continue\"). Parameters: regions \u2013 list of region names budgets \u2013 a tuple with starting budget, increment, and count targets \u2013 list of restoration target names weights \u2013 list of target weights (optional) mapping \u2013 column mappings (optional) Source code in src/gui/infobox.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def show_params ( self , regions , budgets , targets , weights , mapping ): \"\"\" Method called to allow the user to review the optimization parameters read from the various widgets. Displays each parameter and two buttons (\"Cancel\" and \"Continue\"). Arguments: regions: list of region names budgets: a tuple with starting budget, increment, and count targets: list of restoration target names weights: list of target weights (optional) mapping: column mappings (optional) \"\"\" bstart , binc , bcount = budgets fbmax = OP . format_budget_amount ( binc * bcount ) fbstep = OP . format_budget_amount ( binc ) fbstart = OP . format_budget_amount ( bstart ) text = self . preview_message_text text += f ' * Regions: { \", \" . join ( regions ) } \\n\\n ' if bcount > 1 : text += f ' * { bcount } budget levels from { fbstep } up to { fbmax } in increments of { fbstep } \\n\\n ' else : text += f ' * a single budget of { fbstart } \\n\\n ' targets = [ t . split ( ':' )[ - 1 ] for t in targets ] if weights : targets = [ f ' { targets [ i ] } \u2a09 { weights [ i ] } ' for i in range ( len ( targets ))] text += f ' * Targets: { \", \" . join ( targets ) } \\n ' text += f ' * Mapping: { mapping } \\n\\n ' self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'secondary' )) self . append ( pn . Row ( self . cancel_button , self . continue_button )) self . template . open_modal () show_success () Method called after OptiPass has finished running and the results have been parsed successfully. Source code in src/gui/infobox.py 127 128 129 130 131 132 133 134 def show_success ( self ): \"\"\" Method called after OptiPass has finished running and the results have been parsed successfully. \"\"\" self . clear () self . append ( pn . pane . Alert ( self . success_text , alert_type = 'success' )) self . template . open_modal () show_fail ( reason ) Method called if OptiPass failed. Parameters: reason \u2013 string containing the error message Source code in src/gui/infobox.py 136 137 138 139 140 141 142 143 144 145 146 147 148 def show_fail ( self , reason ): \"\"\" Method called if OptiPass failed. Arguments: reason: string containing the error message \"\"\" self . clear () text = self . fail_text . format ( reason ) if str ( reason ) == 'No solution' : text += ' \\n * try increasing the maximum budget' self . append ( pn . pane . Alert ( text , alert_type = 'danger' )) self . template . open_modal () OutputPane Bases: Column After OptiPass has completed the last optimization run the GUI creates an instance of this class and saves it in the Output tab of the top level display. (displayed in a tab widget showing one figure at a time), the second part has tables showing data about barriers included in solutions. Parameters: op \u2013 an OPResult object with the optimization parameters and results Source code in src/gui/output.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , op , tgmap ): \"\"\" Format the output from OptiPass. The first part of the panel has a set of ROI curves (displayed in a tab widget showing one figure at a time), the second part has tables showing data about barriers included in solutions. Arguments: op: an OPResult object with the optimization parameters and results \"\"\" super ( OutputPane , self ) . __init__ () self . append ( pn . pane . HTML ( '<h3>Optimization Results</h3>' , styles = header_styles )) self . append ( self . _make_title ( op )) if op . bcount > 1 : self . append ( pn . pane . HTML ( '<h3>ROI Curves</h3>' )) self . append ( self . _make_figures_tab ( op )) self . append ( pn . pane . HTML ( '<h3>Budget Summary</h3>' )) self . gate_count = op . summary . gates . apply ( len ) . sum () if self . gate_count == 0 : self . append ( pn . pane . HTML ( '<i>No barriers selected -- consider increasing the budget</i>' )) else : self . append ( self . _make_budget_table ( op , tgmap )) self . append ( pn . Accordion ( ( 'Barrier Details' , self . _make_gate_table ( op )), stylesheets = [ accordion_style_sheet ], )) _make_title ( op ) The top section of the output pane is a title showing the optimization parameters. Source code in src/gui/output.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def _make_title ( self , op ): \"\"\" The top section of the output pane is a title showing the optimization parameters. \"\"\" tnames = [ OP . target_frame . loc [ t ] . short for t in op . targets ] if op . weights : tnames = [ f ' { tnames [ i ] } \u2a09 { op . weights [ i ] } ' for i in range ( len ( tnames ))] title = f \"<p><b>Regions:</b> { ', ' . join ( op . regions ) } ;\" title += f \" <b>Targets:</b> { ', ' . join ( tnames ) } ;\" if s := OP . mapping_name : title += f \" <b> { s . capitalize () } :</b> { op . mapping } ;\" if op . bcount > 1 : bmax = op . binc * op . bcount smin = OP . format_budget_amount ( op . binc ) smax = OP . format_budget_amount ( bmax ) title += f \" <b>Budgets:</b> { smin } to { smax } </p>\" else : b = OP . format_budget_amount ( op . bmin ), title += \" <b>Budget:</b> {b} </p>\" return pn . pane . HTML ( title ) _make_figures_tab ( op ) Create a Tabs object with one tab for each ROI curve. Source code in src/gui/output.py 70 71 72 73 74 75 76 77 78 79 80 81 def _make_figures_tab ( self , op ): \"\"\" Create a Tabs object with one tab for each ROI curve. \"\"\" tabs = pn . Tabs ( tabs_location = 'left' , stylesheets = [ output_tab_style_sheet ], ) op . make_roi_curves () for p in op . display_figures : tabs . append ( p ) return tabs _make_budget_table ( op , tgmap ) Make the table of benefits for each budget. Attach a callback function that is called when the user clicks on a row in the table (the callback updates the map to show gates used in a solution). Source code in src/gui/output.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def _make_budget_table ( self , op , tgmap ): \"\"\" Make the table of benefits for each budget. Attach a callback function that is called when the user clicks on a row in the table (the callback updates the map to show gates used in a solution). \"\"\" df = op . budget_table () formatters = { col : NumberFormatter ( format = '0.0' , text_align = 'center' ) for col in df . columns } formatters [ 'Budget' ] = { 'type' : 'money' , 'symbol' : '$' , 'precision' : 0 } formatters [ '# Barriers' ] = NumberFormatter ( format = '0' , text_align = 'center' ) alignment = { 'Budget' : 'right' , 'Net Gain' : 'center' , '# Barriers' : 'center' } table = pn . widgets . Tabulator ( df , show_index = False , hidden_columns = [ 'gates' ], editors = { c : None for c in df . columns }, text_align = alignment , header_align = { c : 'center' for c in df . columns }, formatters = formatters , selectable = True , configuration = { 'columnDefaults' : { 'headerSort' : False }}, ) self . budget_table = df self . make_dots ( table , op , tgmap ) table . on_click ( self . budget_table_cb ) return table _make_gate_table ( op ) Make a table showing details about gates used in solutions. Source code in src/gui/output.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def _make_gate_table ( self , op ): \"\"\" Make a table showing details about gates used in solutions. \"\"\" formatters = { } alignment = { } df = op . gate_table () df . columns = [ OP . format_budget_amount ( int ( s )) if s . isdigit () else s for s in df . columns ] for col in df . columns : if col . startswith ( '$' ) or col in [ 'Primary' , 'Dominant' ]: formatters [ col ] = { 'type' : 'tickCross' , 'crossElement' : '' } alignment [ col ] = 'center' elif col == 'Cost' : formatters [ col ] = { 'type' : 'money' , 'symbol' : '$' , 'precision' : 0 } alignment [ col ] = 'right' table = pn . widgets . Tabulator ( df , show_index = True , frozen_columns = [ 'ID' ], hidden_columns = [ 'count' ], formatters = formatters , text_align = alignment , configuration = { 'columnDefaults' : { 'headerSort' : False }}, header_align = { c : 'center' for c in df . columns }, selectable = False , ) table . disabled = True self . gate_table = df return table make_dots ( plot , op , tgmap ) Called after the output panel is initialized, make a set of glyphs to display for each budget level. Source code in src/gui/output.py 150 151 152 153 154 155 156 157 158 159 160 161 def make_dots ( self , plot , op , tgmap ): \"\"\" Called after the output panel is initialized, make a set of glyphs to display for each budget level. \"\"\" self . selected_row = None self . dots = [] for name , row in self . budget_table . iterrows (): df = tgmap . map_coords () . loc [ row . gates ] c = tgmap . map . circle_dot ( 'x' , 'y' , size = 12 , line_color = 'blue' , fill_color = 'white' , source = df ) c . visible = False self . dots . append ( c ) budget_table_cb ( e ) The callback function invoked when the user clicks a row in the budget table. Use the event to figure out which row was clicked. Hide any dots that were displayed previously, then make the dots for the selected row visible. Source code in src/gui/output.py 163 164 165 166 167 168 169 170 171 172 def budget_table_cb ( self , e ): \"\"\" The callback function invoked when the user clicks a row in the budget table. Use the event to figure out which row was clicked. Hide any dots that were displayed previously, then make the dots for the selected row visible. \"\"\" if n := self . selected_row : self . dots [ n ] . visible = False self . selected_row = e . row self . dots [ self . selected_row ] . visible = True hide_dots () Callback function invoked when users click on a region name in the start panel to hide any dots that might be on the map. Source code in src/gui/output.py 174 175 176 177 178 179 180 181 def hide_dots ( self ): \"\"\" Callback function invoked when users click on a region name in the start panel to hide any dots that might be on the map. \"\"\" if self . selected_row : self . dots [ self . selected_row ] . visible = False self . selected_row = None RegionBox Bases: Column The region box displays the names of each geographic region in the data set, with a checkbox next to the name. When the user clicks on one of the checkboxes several actions are triggered: the set of selected regions is updated, the budget widget is notified so it can update the maximum budget (based on the total cost of all barriers in the current selection), and the map is updated by zooming in to a level that contains only the barriers in the selected regions. Parameters: map \u2013 the TGMap object that will be updated when regions are selected budget \u2013 the BudgetBox object to update when regions are selected Source code in src/gui/regionbox.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , map , budget ): \"\"\" Create the grid of checkboxes and set up the callback function. Arguments: map: the TGMap object that will be updated when regions are selected budget: the BudgetBox object to update when regions are selected \"\"\" super ( RegionBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . map = map self . budget_box = budget self . boxes = { } for name in OP . region_names : box = pn . widgets . Checkbox ( name = name , styles = box_styles , stylesheets = [ box_style_sheet ]) box . param . watch ( self . cb , [ 'value' ]) self . boxes [ name ] = box self . selected = set () self . external_cb = None self . append ( pn . GridBox ( * self . boxes . values (), ncols = 3 )) cb ( * events ) Callback function invoked when one of the checkboxes is clicked. If the new state of the checkbox is 'selected' the region is added to the set of selected regions, otherwise it is removed. After updating the set notify the map widget and any other widgets that have been registered as external callbacks. Source code in src/gui/regionbox.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def cb ( self , * events ): \"\"\" Callback function invoked when one of the checkboxes is clicked. If the new state of the checkbox is 'selected' the region is added to the set of selected regions, otherwise it is removed. After updating the set notify the map widget and any other widgets that have been registered as external callbacks. \"\"\" for e in events : if e . type == 'changed' : r = e . obj . name if e . new : self . selected . add ( r ) else : self . selected . remove ( r ) amount = sum ( OP . total_cost [ x ] for x in self . selected ) self . budget_box . set_budget_max ( amount ) self . map . display_regions ( self . selected ) # self.map.zoom(self.selected) if self . external_cb : self . external_cb () check ( region ) Initialize the box by addidng region to the selection. Source code in src/gui/regionbox.py 62 63 64 65 66 def check ( self , region ): \"\"\" Initialize the box by addidng region to the selection. \"\"\" self . boxes [ region ] . value = True selection () Return a list of the names of currently selected regions. Source code in src/gui/regionbox.py 68 69 70 71 72 def selection ( self ) -> list [ str ]: \"\"\" Return a list of the names of currently selected regions. \"\"\" return list ( self . selected ) add_external_callback ( f ) Save a reference to an external function to call when a region box is clicked. Parameters: f \u2013 aditional function to call when a checkbox is clicked Source code in src/gui/regionbox.py 74 75 76 77 78 79 80 81 def add_external_callback ( self , f ): \"\"\" Save a reference to an external function to call when a region box is clicked. Arguments: f: aditional function to call when a checkbox is clicked \"\"\" self . external_cb = f TargetBox Bases: Column The restoration targets are shown in a matrix with a selection widget next to each target name. The TargetBox widget has two tabs showing different types of selection widgets, either simple checkboxes (shown by a BasicTargetBox) or text entry widgets (shown by WeightedTargetBox). Source code in src/gui/targetbox.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self ): super ( TargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) if OP . mapping_name : lst = [ s . capitalize () for s in OP . target_columns ] label = OP . mapping_name . capitalize () self . mapping_buttons = pn . widgets . RadioBoxGroup ( name = label , options = lst ) mapping_box = pn . Column ( pn . pane . HTML ( f '<b> { label } <b>' , align = 'start' ), self . mapping_buttons , ) else : self . mapping_buttons = None self . tabs = pn . Tabs ( ( 'Basic' , BasicTargetBox ()), ( 'Weighted' , WeightedTargetBox ()), ) row = pn . Row () row . append ( self . tabs ) if self . mapping_buttons : row . append ( mapping_box ) self . append ( row ) make_layout ( obj ) staticmethod Read the target layout (size of grid, location of each target in the grid) Source code in src/gui/targetbox.py 40 41 42 43 44 45 46 47 @staticmethod def make_layout ( obj ): \"\"\" Read the target layout (size of grid, location of each target in the grid) \"\"\" obj . layout = [ s . split () for s in OP . target_layout ] obj . nrows = len ( obj . layout ) obj . ncols = max ( len ( r ) for r in obj . layout ) selection () Get a list of IDs of selected targets from the current target widget. Source code in src/gui/targetbox.py 49 50 51 52 53 def selection ( self ) -> list [ str ]: \"\"\" Get a list of IDs of selected targets from the current target widget. \"\"\" return self . tabs [ self . tabs . active ] . selection () weights () Get target weights from the current target widget. Source code in src/gui/targetbox.py 55 56 57 58 59 def weights ( self ): \"\"\" Get target weights from the current target widget. \"\"\" return self . tabs [ self . tabs . active ] . weights () mapping () If the targets have alternative column name mappings return the selected mapping name Source code in src/gui/targetbox.py 61 62 63 64 65 66 def mapping ( self ): \"\"\" If the targets have alternative column name mappings return the selected mapping name \"\"\" return self . mapping_buttons . value . lower () if OP . mapping_name else None BasicTargetBox Bases: Column The BasicTargetBox widget displays a checkbox next to each target name. Source code in src/gui/targetbox.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def __init__ ( self ): \"\"\" Make the grid of checkboxes. The IDs and descriptions of targets are fetched by calling the make_layout function in the Target class. \"\"\" super ( BasicTargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) TargetBox . make_layout ( self ) self . grid = pn . GridBox ( nrows = self . nrows , ncols = self . ncols ) for row in self . layout : for t in row : s = OP . target_frame . loc [ t ] . long b = pn . widgets . Checkbox ( name = s , styles = box_styles , stylesheets = [ box_style_sheet ], tags = [ t ]) self . grid . append ( b ) self . append ( self . grid ) selection () Return a list of IDs of selected targets. Source code in src/gui/targetbox.py 91 92 93 94 95 def selection ( self ) -> list [ str ]: \"\"\" Return a list of IDs of selected targets. \"\"\" return [ b . tags [ 0 ] for b in self . grid . objects if b . value ] weights () There are no weights (all targets considered equally) so return an empty list. Source code in src/gui/targetbox.py 102 103 104 105 106 def weights ( self ): \"\"\" There are no weights (all targets considered equally) so return an empty list. \"\"\" return [] WeightedTargetBox Bases: Column A WeightedTargetBox shows a text entry widget next to each target to allow users to enter a numeric weight for the target. Source code in src/gui/targetbox.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def __init__ ( self ): \"\"\" Make the grid of text entry widgets. The IDs and descriptions of targets are fetched by calling the make_layout function in the Target class. \"\"\" super ( WeightedTargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) TargetBox . make_layout ( self ) self . grid = pn . GridBox ( nrows = self . nrows , ncols = self . ncols ) for row in self . layout : for t in row : s = OP . target_frame . loc [ t ] . long w = pn . Row () w . append ( pn . widgets . TextInput ( name = '' , placeholder = '' , width = 25 , align = 'center' , stylesheets = [ input_style_sheet ], tags = [ t ])) w . append ( pn . pane . HTML ( s )) self . grid . append ( w ) self . append ( self . grid ) selection () Return a list of IDs of selected targets. Source code in src/gui/targetbox.py 131 132 133 134 135 def selection ( self ) -> list [ str ]: \"\"\" Return a list of IDs of selected targets. \"\"\" return [ w [ 0 ] . tags [ 0 ] for w in self . grid . objects if w [ 0 ] . value ] weights () Return the text content of each non-empty text entry box. Source code in src/gui/targetbox.py 142 143 144 145 146 def weights ( self ) -> list [ str ]: \"\"\" Return the text content of each non-empty text entry box. \"\"\" return [ w [ 0 ] . value for w in self . grid . objects if w [ 0 ] . value ] TGMap A TGMap object manages the display of a map that shows the locations of the barriers in a project. A static method named init is a factory that instantiates a new map. It will read the \"mapinfo\" file for the project and return a reference to a new map object belonging to the class specified in the mapinfo file. Attributes: map \u2013 a Bokeh figure object, with x and y ranges defined by the locations of the barriers dots \u2013 a dictionary that maps region names to a list of circle glyphs for each barrier in a region ranges \u2013 a data frame that has the range of x and y coordinates for each region map_coords () Return a frame that has the coordinates and other info needed to display gates on a map Source code in src/gui/tgmap.py 40 41 42 43 44 45 def map_coords ( self ): ''' Return a frame that has the coordinates and other info needed to display gates on a map ''' return self . _map_coords graphic () Return a reference to the map (a Bokeh figure). Source code in src/gui/tgmap.py 47 48 49 50 51 def graphic ( self ): ''' Return a reference to the map (a Bokeh figure). ''' return self . map display_regions ( selection ) Method called when the user clicks the checkbox next to the name of a region. Set the visible attribute of each dot to True or False depending on whether the region it is in is selected. Parameters: selection \u2013 a list of names of regions currently selected Source code in src/gui/tgmap.py 53 54 55 56 57 58 59 60 61 62 63 def display_regions ( self , selection ): \"\"\" Method called when the user clicks the checkbox next to the name of a region. Set the visible attribute of each dot to True or False depending on whether the region it is in is selected. Arguments: selection: a list of names of regions currently selected \"\"\" for r , dots in self . dots . items (): dots . visible = r in selection StaticMap Bases: TGMap A static map is simply a PNG file downloaded from the server. Source code in src/gui/tgmap.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def __init__ ( self ): url = f \" { OP . server_url } /map/ { OP . project_name } / { OP . mapinfo [ 'map_file' ] } \" logging . info ( f 'Fetching map from { url } ' ) xpixels = 473 ypixels = 533 p = bk . figure ( title = OP . mapinfo [ 'map_title' ], x_range = ( 0 , xpixels ), y_range = ( 0 , ypixels ), tools = OP . mapinfo [ 'map_tools' ], tooltips = [ ( \"Barrier\" , \"@ID\" ), ( \"Region\" , \"@region\" ), ( \"Cost\" , \"@cost\" ) ] ) p . image_url ( url = [ url ], x = 0 , y = ypixels , h = ypixels , w = xpixels ) bf = OP . barrier_frame self . dots = { } for r in OP . region_names : df = bf [ bf . region == r ] c = p . circle ( 'X' , 'Y' , size = 10 , color = 'darkslategray' , source = df ) self . dots [ r ] = c c . visible = False self . map = p df = bf [[ 'region' , 'X' , 'Y' ]] df . columns = [ 'region' , 'x' , 'y' ] self . _map_coords = df TiledMap Bases: TGMap A tiled map uses a tile server to fetch the map image. Fetch the main barrier file to get the coordinates and other data for each barrier. Source code in src/gui/tgmap.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self ): # bf = self._fetch_barriers() self . _map_coords = self . _make_info ( OP . barrier_frame ) self . regions = self . _make_region_list () self . ranges = self . _create_ranges () self . tile_provider = get_provider ( xyz . OpenStreetMap . Mapnik ) p = bk . figure ( title = 'Oregon Coast' , height = 900 , width = 400 , x_range = ( self . _map_coords . x . min () * 0.997 , self . _map_coords . x . max () * 1.003 ), y_range = ( self . _map_coords . y . min () * 0.997 , self . _map_coords . y . max () * 1.003 ), x_axis_type = 'mercator' , y_axis_type = 'mercator' , toolbar_location = 'below' , tools = [ 'pan' , 'wheel_zoom' , 'hover' , 'reset' ], tooltips = [ ( \"ID\" , \"@ID\" ), ( \"Region\" , \"@region\" ), ( \"Type\" , \"@type\" ), ] ) p . add_tile ( self . tile_provider ) p . toolbar . autohide = True self . dots = { } for r in self . regions : df = self . _map_coords [ self . _map_coords . region == r ] c = p . circle ( 'x' , 'y' , size = 5 , color = 'darkslategray' , source = df , tags = list ( df . index )) self . dots [ r ] = c c . visible = False self . map = p self . outer_x = ( self . _map_coords . x . min () * 0.997 , self . _map_coords . x . max () * 1.003 ) self . outer_y = ( self . _map_coords . y . min () * 0.997 , self . _map_coords . y . max () * 1.003 ) _make_info ( bf ) Hidden method, makes a dataframe with attributes needed to display gates on a map. Map latitude and longitude columns in the input frame to Mercator coordinates, and copy the ID, region and barrier types so they can be displayed as tooltips. Source code in src/gui/tgmap.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def _make_info ( self , bf ): \"\"\" Hidden method, makes a dataframe with attributes needed to display gates on a map. Map latitude and longitude columns in the input frame to Mercator coordinates, and copy the ID, region and barrier types so they can be displayed as tooltips. \"\"\" df = bf [[ 'region' , 'type' ]] R = 6378137.0 map_coords = pd . concat ([ df , np . radians ( bf . X ) * R , np . log ( np . tan ( np . pi / 4 + np . radians ( bf . Y ) / 2 )) * R ], axis = 1 ) map_coords . columns = [ 'region' , 'type' , 'x' , 'y' ] return map_coords _make_region_list () Hidden method, make a list of unique region names, sorted by latitude, so regions are displayed in order from north to south. Updates the list of names in the OP object. Source code in src/gui/tgmap.py 171 172 173 174 175 176 177 178 179 180 181 def _make_region_list ( self ): ''' Hidden method, make a list of unique region names, sorted by latitude, so regions are displayed in order from north to south. Updates the list of names in the OP object. ''' df = self . _map_coords [[ 'region' , 'y' ]] mf = df . groupby ( 'region' ) . mean ( numeric_only = True ) . sort_values ( by = 'y' , ascending = False ) names = list ( mf . index ) OP . region_names = names return names _create_ranges () Hidden method, called by the constructor to create a Pandas Dataframe containing the range of latitudes and longitudes of the barriers in a project. Source code in src/gui/tgmap.py 183 184 185 186 187 188 189 190 191 192 193 194 195 def _create_ranges ( self ): \"\"\" Hidden method, called by the constructor to create a Pandas Dataframe containing the range of latitudes and longitudes of the barriers in a project. \"\"\" g = self . _map_coords . groupby ( 'region' ) return pd . DataFrame ({ 'x_min' : g . min () . x , 'x_max' : g . max () . x , 'y_min' : g . min () . y , 'y_max' : g . max () . y , }) display_regions ( selection ) Update the map, setting the x and y range based on the currently selected regions. Parameters: selection \u2013 a list of names of regions currently selected Source code in src/gui/tgmap.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def display_regions ( self , selection ): \"\"\" Update the map, setting the x and y range based on the currently selected regions. Arguments: selection: a list of names of regions currently selected \"\"\" super () . display_regions ( selection ) if len ( selection ) > 0 : xmin = min ([ self . ranges [ 'x_min' ][ r ] for r in selection ]) xmax = max ([ self . ranges [ 'x_max' ][ r ] for r in selection ]) ymin = min ([ self . ranges [ 'y_min' ][ r ] for r in selection ]) ymax = max ([ self . ranges [ 'y_max' ][ r ] for r in selection ]) mx = ( xmax + xmin ) / 2 my = ( ymax + ymin ) / 2 dx = max ( 5000 , xmax - xmin ) dy = max ( 5000 , ymax - ymin ) ar = self . map . height / self . map . width if dy / dx > ar : dx = dy / ar else : dy = dx * ar self . map . x_range . update ( start = mx - dx / 2 - 5000 , end = mx + dx / 2 + 5000 ) self . map . y_range . update ( start = my - dy / 2 , end = my + dy / 2 ) else : self . map . x_range . update ( start = self . outer_x [ 0 ], end = self . outer_x [ 1 ]) self . map . y_range . update ( start = self . outer_y [ 0 ], end = self . outer_y [ 1 ]) self . map . add_tile ( self . tile_provider )","title":"GUI"},{"location":"gui/#gui","text":"The Python syntax for defining a new class that is derived from an existing class uses a class statement. This is the statement that defines the RegionBox class: class RegionBox(pn.Column): ... pn.Column is an existing widget class, defined in the Panel library. That means our new RegionBox objects will be special types of columns that can be inserted into the GUI at some place. The code that is called to create a new object is a function named __init__ defined inside the class. The first argument to __init__ is always self , which is a reference to the object being built. Here is a simplified version of the __init__ function for the RegionBox class (the actual definition is shown below, in the documentation for RegionBox): class RegionBox(pn.Column): def __init__(self, project): self.boxes = { } for name in OP.region_names: box = pn.widgets.Checkbox(name=name, styles=box_styles, stylesheets=[box_style_sheet]) box.param.watch(self.cb, ['value']) self.boxes[name] = box When this function is called, it initializes a variable named boxes to be an empty dictionary. The for loop iterates over all the region names. It makes a Checkbox widget for each region and adds the box to the dictionary. The line in the middle of the loop that calls box.param.watch is where all the \"magic\" happens. This function call tells the GUI that whenever a checkbox is clicked it should call a function named cb that is also defined inside the RegionBox class. Here is a simplified version: def cb(self, event): r = event.obj.name if event.new: self.selected.add(r) else: self.selected.remove(r) The name cb is short for \"callback\", a common name for this type of function. The parameter named event has information about what the user just did. In this case, we want to get the name of the button (which will be one of the region names) and then update the set of selected regions. If the button was turned on we add the region name to the set, otherwise we remove it.","title":"GUI"},{"location":"gui/#tidegatesapp","text":"Bases: BootstrapTemplate The web application is based on the Bootstrap template provided by Panel. It displays a map (an instance of the TGMap class) in the sidebar. The main content area has a Tabs widget with five tabs: a welcome message, a help page, the main page (described below) and two tabs for displaying outputs. The application also displays several small help buttons next to the main widgets. Clicking one of these buttons brings up a floating window with information about the widget. The main tab (labeled \"Start\") displays the widgets that allow the user to specify optimization parameters: region names, budget levels, and restoration targets. It also has a Run button. When the user clicks this button the callback function makes sure the necessary parameters have been defined and then uses the template's modal dialog area. Clicking the \"OK\" button in that dialog invokes another callback, defined here, that runs the optimizer. Parameters: params \u2013 runtime options passed to the parent class constructor Source code in src/gui/app.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def __init__ ( self , ** params ): \"\"\" Initialize the application. Arguments: params: runtime options passed to the parent class constructor \"\"\" super ( TideGatesApp , self ) . __init__ ( ** params ) # self.project_menu = pn.widgets.Select(options=['Demo','Oregon'], width=150) # self.header.append(pn.Row( # pn.layout.HSpacer(), # self.project_menu # )) self . map = TGMap . init () self . map_pane = pn . Column ( pn . panel ( self . map . graphic ()) ) self . budget_box = BudgetBox () self . region_boxes = RegionBox ( self . map , self . budget_box ) self . target_boxes = TargetBox () self . optimize_button = pn . widgets . Button ( name = 'Run Optimizer' , stylesheets = [ button_style_sheet ]) self . info = InfoBox ( self , self . run_cb ) self . modal . append ( self . info ) self . map_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . map_help_button . on_click ( self . map_help_cb ) self . region_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . region_help_button . on_click ( self . region_help_cb ) self . budget_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . budget_help_button . on_click ( self . budget_help_cb ) self . target_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . target_help_button . on_click ( self . target_help_cb ) self . climate_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . climate_help_button . on_click ( self . climate_help_cb ) # self.tab_height = int(self.map.graphic().height * 1.05) self . tab_height = 900 welcome_tab = pn . Column ( self . section_head ( 'Welcome' ), pn . pane . HTML ( OP . fetch_html_file ( 'welcome.html' )), height = self . tab_height , scroll = True , ) help_tab = pn . Column ( self . section_head ( 'Instructions' ), pn . pane . HTML ( OP . fetch_html_file ( 'help.html' )), height = self . tab_height , scroll = True , ) start_tab = pn . Column ( self . section_head ( 'Geographic Regions' , self . region_help_button ), self . region_boxes , self . section_head ( 'Budgets' , self . budget_help_button ), self . budget_box , self . section_head ( 'Targets' , self . target_help_button ), self . target_boxes , self . optimize_button , ) output_tab = pn . Column ( self . section_head ( 'Nothing to See Yet' ), pn . pane . HTML ( '<p>After running the optimizer this tab will show the results.</p>' ) ) download_tab = pn . Column ( self . section_head ( 'Nothing to Download Yet' ), pn . pane . HTML ( '<p>After running the optimizer use this tab to save the results.</p>' ) ) self . tabs = pn . Tabs ( ( 'Home' , welcome_tab ), ( 'Help' , help_tab ), ( 'Start' , start_tab ), ( 'Output' , output_tab ), ( 'Download' , download_tab ), stylesheets = [ tab_style_sheet ], # tabs_location='left', # sizing_mode = 'fixed', # width=800, # height=700, ) self . sidebar . append ( pn . Row ( self . map_pane , self . map_help_button )) self . main . append ( self . tabs ) self . optimize_button . on_click ( self . validate_settings ) for r in DevOP . default_regions (): self . region_boxes . check ( r ) self . budget_box . set_value ( DevOP . default_budget ()) self . target_boxes . set_selection ( DevOP . default_targets ()) if DevOP . results_dir (): self . run_optimizer () self . tabs . active = OP . initial_tab","title":"TideGatesApp"},{"location":"gui/#src.gui.app.TideGatesApp.section_head","text":"Create an HTML header for one of the sections in the Start tab. Source code in src/gui/app.py 148 149 150 151 152 153 def section_head ( self , s , b = None ): \"\"\" Create an HTML header for one of the sections in the Start tab. \"\"\" header = pn . pane . HTML ( f '<h3> { s } </h3>' , styles = header_styles ) return header if b is None else pn . Row ( header , b )","title":"section_head"},{"location":"gui/#src.gui.app.TideGatesApp.validate_settings","text":"Callback function invoked when the user clicks the Run Optimizer button. Source code in src/gui/app.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def validate_settings ( self , _ ): \"\"\" Callback function invoked when the user clicks the Run Optimizer button. \"\"\" regions = self . region_boxes . selection () budget = self . budget_box . defined () targets = self . target_boxes . selection () if len ( regions ) == 0 or ( not budget ) or len ( targets ) == 0 : self . info . show_missing ( regions , budget , targets ) return if weights := self . target_boxes . weights (): if not all ([ w . isdigit () and ( 1 <= int ( w ) <= 5 ) for w in weights ]): self . info . show_invalid_weights ( weights ) return mapping = self . target_boxes . mapping () self . info . show_params ( regions , self . budget_box . values (), targets , weights , mapping )","title":"validate_settings"},{"location":"gui/#src.gui.app.TideGatesApp.run_cb","text":"Callback function invoked when the user clicks the Continue button after verifying the parameter options. Wrap the call to the function that runs the optimizer in code that shows the loading icon and opens a message when the function returns. Source code in src/gui/app.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def run_cb ( self , _ ): \"\"\" Callback function invoked when the user clicks the Continue button after verifying the parameter options. Wrap the call to the function that runs the optimizer in code that shows the loading icon and opens a message when the function returns. \"\"\" try : self . close_modal () self . main [ 0 ] . loading = True self . run_optimizer () self . main [ 0 ] . loading = False self . info . show_success () except OPServerError as err : self . main [ 0 ] . loading = False self . info . show_fail ( err )","title":"run_cb"},{"location":"gui/#src.gui.app.TideGatesApp.run_optimizer","text":"Use the settings in the widgets to run OptiPass, save the results in the output tab. Source code in src/gui/app.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def run_optimizer ( self ): \"\"\" Use the settings in the widgets to run OptiPass, save the results in the output tab. \"\"\" params = [ self . region_boxes . selection (), self . budget_box . values (), self . target_boxes . selection (), self . target_boxes . weights (), self . target_boxes . mapping (), ] resp = OP . run_optimizer ( * params ) params += resp res = OPResult ( * params ) output = OutputPane ( res , self . map ) self . region_boxes . add_external_callback ( output . hide_dots ) self . tabs [ 3 ] = ( 'Output' , pn . Column ( output , height = self . tab_height , scroll = True )) self . tabs [ 4 ] = ( 'Download' , pn . Column ( DownloadPane ( res ), height = self . tab_height , scroll = True ))","title":"run_optimizer"},{"location":"gui/#src.gui.app.TideGatesApp.map_help_cb","text":"Callback function for the help button next to the map in the sidebar. Source code in src/gui/app.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def map_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the map in the sidebar. \"\"\" msg = pn . pane . HTML ( ''' <p>When you move your mouse over the map the cursor will change to a \"crosshairs\" symbol and a set of buttons will appear below the map. Navigating with the map is similar to using Google maps or other online maps:</p> <ul> <li>Left-click and drag to pan (move left and right or up and down).</li> <li>If you want to zoom in and out, first click the magnifying glass button below the map; then you can zoom in and out using the scroll wheel on your mouse.</li> <li>Click the refresh button to restore the map to its original size and location.</li> </ul> ''' ) self . tabs [ 0 ] . append ( pn . layout . FloatPanel ( msg , name = 'Map Controls' , contained = False , position = 'center' , width = 400 ))","title":"map_help_cb"},{"location":"gui/#src.gui.app.TideGatesApp.region_help_cb","text":"Callback function for the help button next to the region box widget in the start tab. Source code in src/gui/app.py 232 233 234 235 236 237 238 239 240 241 def region_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the region box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>Select a region by clicking in the box to the left of an estuary name.</p> <p>Each time you click in a box the map will be updated to show the positions of the barriers that are in our database for the estuary.</p> <p>You must select at least one region before you run the optimizer.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Geographic Regions' , contained = False , position = 'center' , width = 400 ))","title":"region_help_cb"},{"location":"gui/#src.gui.app.TideGatesApp.budget_help_cb","text":"Callback function for the help button next to the budget box widget in the start tab. Source code in src/gui/app.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def budget_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the budget box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>There are three ways to specify the budgets used by the optimizer.</p> <H4>Basic</H4> <p>The simplest method is to specify an upper limit by moving the slider back and forth. When you use this method, the optimizer will run 10 times, ending at the value you select with the slider. For example, if you set the slider at $10M (the abbreviation for $10 million), the optimizer will make ROI curves based on budgets of $1M, $2M, <i>etc</i>, up to the maximum of $10M.</p> <p>Note that the slider is disabled until you select one or more regions. That's because the maximum value depends on the costs of the gates in each region. For example, the total cost of all gates in the Coquille region is $11.8M. Once you choose that region, you can move the budget slider left and right to pick a maximum budget for the optimizer to consider. <H4>Advanced</H4> <p>If you click on the Advanced tab in this section you will see ways to specify the budget interval and the number of budgets.</p> <p>You can use this method if you want more control over the layout of the ROI curves, for example you can include more points by increasing the number of budgets.</p> <H4>Fixed</H4> <p>If you know exactly how much money you have to spend you can enter that amount by clicking on the Fixed tab and entering the budget amount.</p> <p>The optimizer will run just once, using that budget. The output will have tables showing the gates identified by the optimizer, but there will be no ROI curve.</p> <p>When entering values, you can write the full amount, with or without commas (<i>e.g.</i>11,500,000 or 11500000) or use the abbreviated form (11.5M).</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Budget Levels' , contained = False , position = 'center' , width = 400 ))","title":"budget_help_cb"},{"location":"gui/#src.gui.app.TideGatesApp.target_help_cb","text":"Callback function for the help button next to the target box widget in the start tab. Source code in src/gui/app.py 264 265 266 267 268 269 270 271 272 273 def target_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the target box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>Click boxes next to one or more target names to have the optimizer include those targets in its calculations.</p> <p>The optimizer will create an ROI curve for each target selected. </p> <p>If more than one target is selected the optimizer will also generate an overall \"net benefit\" curve based on considering all targets at the same time.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Targets' , contained = False , position = 'center' , width = 400 ))","title":"target_help_cb"},{"location":"gui/#src.gui.app.TideGatesApp.climate_help_cb","text":"Callback function for the help button next to the climate scenario checkbox in the start tab. Source code in src/gui/app.py 275 276 277 278 279 280 281 282 283 def climate_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the climate scenario checkbox in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>By default the optimizer uses current water levels when computing potential benefits. Click the button next to <b>Future</b> to have it use water levels expected due to climate change.</p> <p>The future scenario uses two projected water levels, both for the period to 2100. For fish habitat targets, the future water level is based on projected sea level rise of 5.0 feet. For agriculture and infrastructure targets, the future water level is projected to be 7.2 feet, which includes sea level rise and the probabilities of extreme water levels causing flooding events.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Targets' , contained = False , position = 'center' , width = 400 ))","title":"climate_help_cb"},{"location":"gui/#budgetbox","text":"Bases: Column There are three ways users can specify the range of budget values when running OptiPass. A BudgetBox widget has one tab for each option. The widgets displayed inside a tab are defined by their own classes (BasicBudgetBox, AdvancedBudgetBox, and FixedBudgetBox). Source code in src/gui/budgets.py 19 20 21 22 23 24 25 26 def __init__ ( self ): super ( BudgetBox , self ) . __init__ () self . tabs = pn . Tabs ( ( 'Basic' , BasicBudgetBox ()), ( 'Advanced' , AdvancedBudgetBox ()), ( 'Fixed' , FixedBudgetBox ()), ) self . append ( self . tabs )","title":"BudgetBox"},{"location":"gui/#src.gui.budgets.BudgetBox.set_budget_max","text":"When the user selects or deselects a region the budget widgets need to know the new total cost for all the selected regions. This method passes that information to each of the budget widgets. Parameters: n ( int ) \u2013 the new maximum budget amount Source code in src/gui/budgets.py 28 29 30 31 32 33 34 35 36 37 38 def set_budget_max ( self , n : int ): \"\"\" When the user selects or deselects a region the budget widgets need to know the new total cost for all the selected regions. This method passes that information to each of the budget widgets. Arguments: n: the new maximum budget amount \"\"\" for t in self . tabs : t . set_budget_max ( n )","title":"set_budget_max"},{"location":"gui/#src.gui.budgets.BudgetBox.values","text":"Return the budget settings for the currently selected budget type. Get the widget values from the active budget type, convert them into a tuple of values that will be passed to the optimizer. Returns: bmin \u2013 the starting budget binc \u2013 the increment between budget values bcnt \u2013 the number of budget values Source code in src/gui/budgets.py 40 41 42 43 44 45 46 47 48 49 50 51 def values ( self ): \"\"\" Return the budget settings for the currently selected budget type. Get the widget values from the active budget type, convert them into a tuple of values that will be passed to the optimizer. Returns: bmin: the starting budget binc: the increment between budget values bcnt: the number of budget values \"\"\" return self . tabs [ self . tabs . active ] . values ()","title":"values"},{"location":"gui/#src.gui.budgets.BudgetBox.defined","text":"Return True if the user has defined a budget using the current tab Source code in src/gui/budgets.py 53 54 55 56 57 def defined ( self ): \"\"\" Return True if the user has defined a budget using the current tab \"\"\" return self . tabs [ self . tabs . active ] . defined ()","title":"defined"},{"location":"gui/#src.gui.budgets.BudgetBox.set_value","text":"Initialize the GUI by setting an initial budget value Source code in src/gui/budgets.py 59 60 61 62 63 def set_value ( self , n ): \"\"\" Initialize the GUI by setting an initial budget value \"\"\" self . tabs [ self . tabs . active ] . set_value ( n )","title":"set_value"},{"location":"gui/#basicbudgetbox","text":"Bases: WidgetBox The default budget widget displays a slider that ranges from 0 up to a maximum value based on the total cost of all barriers in currently selected regions. Source code in src/gui/budgets.py 87 88 89 90 91 92 93 94 95 96 97 98 def __init__ ( self ): super ( BasicBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . labels = [ x [ 0 ] for x in self . levels ] self . map = { x [ 0 ]: x [ 1 ] for x in self . levels } self . slider = pn . widgets . DiscreteSlider ( options = self . labels [: self . MIN_LEVELS ], value = self . labels [ 0 ], name = 'Maximum Budget' , margin = ( 20 , 20 , 20 , 20 ), stylesheets = [ slider_style_sheet ], ) self . append ( self . slider )","title":"BasicBudgetBox"},{"location":"gui/#src.gui.budgets.BasicBudgetBox.set_budget_max","text":"Choose a maximum budget by scanning a table of budget levels to find the first one less than the total cost. Parameters: n \u2013 the total cost of all barriers in the current selection. Source code in src/gui/budgets.py 100 101 102 103 104 105 106 107 108 109 110 111 112 def set_budget_max ( self , n ): \"\"\" Choose a maximum budget by scanning a table of budget levels to find the first one less than the total cost. Arguments: n: the total cost of all barriers in the current selection. \"\"\" for i in range ( len ( self . levels ) - 1 , - 1 , - 1 ): if n >= self . levels [ i ][ 1 ]: break i = max ( i , self . MIN_LEVELS ) self . slider . options = self . labels [: i + 1 ]","title":"set_budget_max"},{"location":"gui/#src.gui.budgets.BasicBudgetBox.values","text":"The basic budget always has the same number of budgets and always starts with $0. Determine the increment by dividing the max budget in the slider by the number of budgets. Source code in src/gui/budgets.py 116 117 118 119 120 121 122 123 def values ( self ): \"\"\" The basic budget always has the same number of budgets and always starts with $0. Determine the increment by dividing the max budget in the slider by the number of budgets. \"\"\" x = self . map [ self . slider . value ] return 0 , x // self . BUDGET_COUNT , self . BUDGET_COUNT","title":"values"},{"location":"gui/#src.gui.budgets.BasicBudgetBox.defined","text":"The basic budget is set if the slider is not in the first location. Source code in src/gui/budgets.py 125 126 127 128 129 def defined ( self ): \"\"\" The basic budget is set if the slider is not in the first location. \"\"\" return self . slider . value != '$0'","title":"defined"},{"location":"gui/#src.gui.budgets.BasicBudgetBox.set_value","text":"Set the slider to n Source code in src/gui/budgets.py 131 132 133 134 135 def set_value ( self , n ): \"\"\" Set the slider to n \"\"\" self . slider . value = self . slider . options [ n ]","title":"set_value"},{"location":"gui/#fixedbudgetbox","text":"Bases: WidgetBox This option is for situations where a user knows exactly how much money they have to spend and want to know the optimal set of barriers to replace for that amount of money. OptiPass is run twice -- once to determine the current passabilities, and once to compute the benefit from the specified budget. The widget simply displays a box where the user enters the dollar amount for their budget. Source code in src/gui/budgets.py 147 148 149 150 def __init__ ( self ): super ( FixedBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . input = pn . widgets . TextInput ( name = 'Budget Amount' , value = '$' ) self . append ( self . input )","title":"FixedBudgetBox"},{"location":"gui/#src.gui.budgets.FixedBudgetBox.values","text":"A fixed budget has one value, returned as the starting budget. The the increment is 0 and count is 1. Source code in src/gui/budgets.py 155 156 157 158 159 160 161 162 163 164 def values ( self ): \"\"\" A fixed budget has one value, returned as the starting budget. The the increment is 0 and count is 1. \"\"\" s = self . input . value if s . startswith ( '$' ): s = s [ 1 :] n = self . parse_dollar_amount ( self . input . value ) return n , 0 , 1","title":"values"},{"location":"gui/#src.gui.budgets.FixedBudgetBox.defined","text":"The fixed budget is set if the text box is not empty. Source code in src/gui/budgets.py 166 167 168 169 170 def defined ( self ): \"\"\" The fixed budget is set if the text box is not empty. \"\"\" return self . parse_dollar_amount ( self . input . value ) > 0","title":"defined"},{"location":"gui/#src.gui.budgets.FixedBudgetBox.set_value","text":"Initialize the budget to n Source code in src/gui/budgets.py 172 173 174 175 176 def set_value ( self , n ): \"\"\" Initialize the budget to n \"\"\" self . input . value = f '$ { n } '","title":"set_value"},{"location":"gui/#src.gui.budgets.FixedBudgetBox.parse_dollar_amount","text":"Make sure the string entered by the user has an acceptable format. It can be all digits (e.g. \"1500000\"), or digits separated by commas (e.g. \"1,500,000\"), or a number followed by a K or M (e.g. \"1.5M\"). There can be a dollar sign at the front of the string. Parameters: s ( str ) \u2013 the string entered into the text box Returns: \u2013 the value of the string converted into an integer Source code in src/gui/budgets.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def parse_dollar_amount ( self , s : str ): \"\"\" Make sure the string entered by the user has an acceptable format. It can be all digits (e.g. \"1500000\"), or digits separated by commas (e.g. \"1,500,000\"), or a number followed by a K or M (e.g. \"1.5M\"). There can be a dollar sign at the front of the string. Arguments: s: the string entered into the text box Returns: the value of the string converted into an integer \"\"\" try : if s . startswith ( '$' ): s = s [ 1 :] if s . endswith (( 'K' , 'M' )): multiplier = 1000 if s . endswith ( 'K' ) else 1000000 res = int ( float ( s [: - 1 ]) * multiplier ) elif ',' in s : parts = s . split ( ',' ) assert len ( parts [ 0 ]) <= 3 and ( len ( parts ) == 1 or all ( len ( p ) == 3 for p in parts [ 1 :])) res = int ( '' . join ( parts )) else : res = 0 if s == '' else int ( s ) return res except Exception : return 0","title":"parse_dollar_amount"},{"location":"gui/#advancedbudgetbox","text":"Bases: WidgetBox The \"advanced\" option gives the user the most control over the budget values processed by OptiPass by letting them specify the number of budget levels (in the basic budget there are always 10 budget levels). This box has three widgets: a slider to specify the maximum amount, another slider to specify the increment between budgets, and an input box to specify the number of budgets. Adjusting the value of any of these widgets automatically updates the other two. For example, if the maximum is set to $1M and the number of budgets is 10, the increment is $100K. If the user changes the number of budgets to 20, the increment drops to $50K. Or if they change the maximum to $2M, the increment increases to $200K. Source code in src/gui/budgets.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __init__ ( self ): super ( AdvancedBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 ), width = self . BOX_WIDTH ) self . cap = 0 self . max_slider = pn . widgets . FloatSlider ( name = 'Maximum Budget' , start = 0 , end = 1 , step = self . MAX_STEP , value = 0 , width = self . MAX_SLIDER_WIDTH , format = NumeralTickFormatter ( format = '$0,0' ), stylesheets = [ slider_style_sheet ], ) self . inc_slider = pn . widgets . FloatSlider ( name = 'Budget Interval' , start = 0 , end = 1 , step = self . INC_STEP , value = 0 , width = self . INC_SLIDER_WIDTH , format = NumeralTickFormatter ( format = '$0,0' ), stylesheets = [ slider_style_sheet ], ) self . count_input = pn . widgets . IntInput ( value = 10 , step = 1 , start = self . COUNT_MIN , end = self . COUNT_MAX , width = 75 , ) self . append ( pn . GridBox ( nrows = 2 , ncols = 2 , objects = [ self . max_slider , self . inc_slider , pn . pane . HTML ( '<b>Limit: N/A<b>' ), pn . Row ( pn . pane . HTML ( '#Budgets:' ), self . count_input , align = ( 'start' , 'center' )) ] )) self . max_slider . param . watch ( self . max_updated , [ 'value' ]) self . inc_slider . param . watch ( self . inc_updated , [ 'value' ]) self . count_input . param . watch ( self . count_updated , [ 'value' ])","title":"AdvancedBudgetBox"},{"location":"gui/#src.gui.budgets.AdvancedBudgetBox.values","text":"In this widget the budget increment and budget count are determined by the values in the corresponding widgets. Source code in src/gui/budgets.py 281 282 283 284 285 286 def values ( self ): \"\"\" In this widget the budget increment and budget count are determined by the values in the corresponding widgets. \"\"\" return 0 , self . inc_slider . value , self . count_input . value","title":"values"},{"location":"gui/#src.gui.budgets.AdvancedBudgetBox.defined","text":"The advance budget is set if the increment is not 0 Source code in src/gui/budgets.py 288 289 290 291 292 def defined ( self ): \"\"\" The advance budget is set if the increment is not 0 \"\"\" return self . inc_slider . value > 0","title":"defined"},{"location":"gui/#src.gui.budgets.AdvancedBudgetBox.set_value","text":"Set the budget to n Source code in src/gui/budgets.py 294 295 296 297 298 def set_value ( self , n ): \"\"\" Set the budget to n \"\"\" self . max_slider . value = n","title":"set_value"},{"location":"gui/#src.gui.budgets.AdvancedBudgetBox.set_budget_max","text":"Called when the user selects or deselects a region. Save the new maximum, and update the value of the increment based on the new maximum. Parameters: n \u2013 the total cost of all barriers in the selected regions. Source code in src/gui/budgets.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def set_budget_max ( self , n ): \"\"\" Called when the user selects or deselects a region. Save the new maximum, and update the value of the increment based on the new maximum. Arguments: n: the total cost of all barriers in the selected regions. \"\"\" self . max_slider . end = max ( 1 , n ) self . max_slider . start = self . MAX_STEP self . inc_slider . end = max ( 1 , n // 2 ) self . inc_slider . start = max ( self . INC_STEP , n / self . COUNT_MAX ) lim = 'N/A' if n == 0 else f '$ { n / 1000000 : .2f } M' self . objects [ 0 ][ 2 ] = pn . pane . HTML ( f '<b>Limit: { lim } </b>' )","title":"set_budget_max"},{"location":"gui/#src.gui.budgets.AdvancedBudgetBox.max_updated","text":"Callback function invoked when the user moves the maximum budget slider. Computes a new budget increment. Source code in src/gui/budgets.py 315 316 317 318 319 320 321 322 323 def max_updated ( self , e ): \"\"\" Callback function invoked when the user moves the maximum budget slider. Computes a new budget increment. \"\"\" try : self . inc_slider . value = self . max_slider . value // self . count_input . value except ArithmeticError : pass","title":"max_updated"},{"location":"gui/#src.gui.budgets.AdvancedBudgetBox.inc_updated","text":"Callback function invoked when the user changes the budget increment. Computes a new number of budgets. Source code in src/gui/budgets.py 325 326 327 328 329 330 331 332 333 334 335 def inc_updated ( self , e ): \"\"\" Callback function invoked when the user changes the budget increment. Computes a new number of budgets. \"\"\" try : c = max ( self . COUNT_MIN , self . max_slider . value // self . inc_slider . value ) c = min ( self . COUNT_MAX , c ) self . count_input . value = c except ArithmeticError : pass","title":"inc_updated"},{"location":"gui/#src.gui.budgets.AdvancedBudgetBox.count_updated","text":"Callback function invoked when the user changes the number of budget levels. Computes a new budget increment. Source code in src/gui/budgets.py 337 338 339 340 341 342 343 344 345 def count_updated ( self , e ): \"\"\" Callback function invoked when the user changes the number of budget levels. Computes a new budget increment. \"\"\" try : self . inc_slider . value = self . max_slider . value // self . count_input . value except ArithmeticError : pass","title":"count_updated"},{"location":"gui/#downloadpane","text":"Bases: Column After OptiPass has completed the last optimization run the GUI creates an instance of this class and saves it in the Download tab of the top level display. Check the output panel to see which plots were created and to enable the net benefit plot if there is one. The pane also has a form to allow the user to enter the name of the download file, the format for the figures, and a button to click when they are ready to download the data. Parameters: op \u2013 the OPResult object containing data tables and plots Source code in src/gui/output.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def __init__ ( self , op ): \"\"\" Display a set of checkboxes for the user to select what sort of data to include in a zip file. If the gate table is not empty enable table downloads. Check the output panel to see which plots were created and to enable the net benefit plot if there is one. The pane also has a form to allow the user to enter the name of the download file, the format for the figures, and a button to click when they are ready to download the data. Arguments: op: the OPResult object containing data tables and plots \"\"\" super ( DownloadPane , self ) . __init__ () self . op = op self . folder_name = self . _make_folder_name () self . grid = pn . GridBox ( ncols = 2 ) self . boxes = { } for x in [ self . NB , self . BS , self . IT , self . BD ]: b = pn . widgets . Checkbox ( name = x , styles = box_styles , stylesheets = [ box_style_sheet ]) if x in [ self . NB , self . IT ]: b . disabled = True b . value = False else : b . value = True self . boxes [ x ] = b self . grid . objects . append ( b ) self . filename_input = pn . widgets . TextInput ( name = '' , value = self . folder_name , ) self . image_type = pn . widgets . RadioBoxGroup ( name = 'IFF' , options = [ 'HTML' , 'PDF' , 'PNG' , 'JPEG' ], inline = True ) self . make_archive_button = pn . widgets . Button ( name = 'Create Output Folder' , stylesheets = [ button_style_sheet ]) self . make_archive_button . on_click ( self . _archive_cb ) self . append ( pn . pane . HTML ( '<h3>Save Outputs</h3>' , styles = header_styles )) if len ( self . op . matrix ) > 0 : self . append ( pn . pane . HTML ( '<b>Items to Include in the Output Folder:</b>' )), self . append ( self . grid ) self . append ( pn . Row ( pn . pane . HTML ( '<b>Image File Format:</b>' ), self . image_type , margin = ( 20 , 0 , 0 , 0 ), )) self . append ( pn . Row ( pn . pane . HTML ( '<b>Output Folder Name:</b>' ), self . filename_input , margin = ( 20 , 0 , 0 , 0 ), )) self . append ( self . make_archive_button ) self . append ( pn . pane . HTML ( '<p>placeholder</p>' , visible = False )) # if there are figures at least one of them is an individual target, so enable # that option; if there is a net benefit figure it's the first figure, enable it # if it's there if len ( self . op . display_figures ) > 0 : if self . op . display_figures [ 0 ][ 0 ] == 'Net' : self . boxes [ self . NB ] . value = True self . boxes [ self . NB ] . disabled = False self . boxes [ self . IT ] . value = True self . boxes [ self . IT ] . disabled = False","title":"DownloadPane"},{"location":"gui/#src.gui.output.DownloadPane._make_folder_name","text":"Use the region names, target names, and budget range to create the default name of the zip file. Source code in src/gui/output.py 263 264 265 266 267 268 269 270 271 272 273 274 275 def _make_folder_name ( self ): \"\"\" Use the region names, target names, and budget range to create the default name of the zip file. \"\"\" parts = [ s [: 3 ] for s in self . op . regions ] lst = self . op . targets if self . op . weights : lst = [ f ' { lst [ i ] } x { self . op . weights [ i ] } ' for i in range ( len ( lst ))] parts . extend ( lst ) parts . append ( OP . format_budget_amount ( self . op . binc * self . op . bcount )[ 1 :]) if self . op . mapping : parts . append ( self . op . mapping ) return '_' . join ( parts )","title":"_make_folder_name"},{"location":"gui/#src.gui.output.DownloadPane._archive_cb","text":"Function called when the user clicks the Download button. Create the output folder and compress it. When the archive is ready, display a FileDownload widget with a button that starts the download. Source code in src/gui/output.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def _archive_cb ( self , e ): \"\"\" Function called when the user clicks the Download button. Create the output folder and compress it. When the archive is ready, display a FileDownload widget with a button that starts the download. \"\"\" if not any ([ x . value for x in self . boxes . values ()]): return self . loading = True base = self . _make_archive_dir () self . _save_files ( base ) p = make_archive ( base , 'zip' , base ) self . loading = False self [ - 1 ] = pn . widgets . FileDownload ( file = p , filename = self . filename + '.zip' , stylesheets = [ button_style_sheet ])","title":"_archive_cb"},{"location":"gui/#src.gui.output.DownloadPane._make_archive_dir","text":"Create an empty directory for the download, using the name in the form. Source code in src/gui/output.py 292 293 294 295 296 297 298 299 300 301 def _make_archive_dir ( self ): \"\"\" Create an empty directory for the download, using the name in the form. \"\"\" self . filename = self . filename_input . value_input or self . filename_input . value archive_dir = Path . cwd () / 'tmp' / self . filename if Path . exists ( archive_dir ): rmtree ( archive_dir ) Path . mkdir ( archive_dir ) return archive_dir","title":"_make_archive_dir"},{"location":"gui/#src.gui.output.DownloadPane._save_files","text":"Write the tables and figures to the download directory. Parameters: loc \u2013 the path to the directory. Source code in src/gui/output.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def _save_files ( self , loc ): \"\"\" Write the tables and figures to the download directory. Arguments: loc: the path to the directory. \"\"\" figures = self . op . display_figures if self . image_type . value == 'HTML' else self . op . download_figures for name , fig in figures : if name == 'Net' and not self . boxes [ self . NB ] . value : continue if name != 'Net' and not self . boxes [ self . IT ] . value : continue if self . image_type . value == 'HTML' : savehtml ( fig , filename = loc / f ' { name } .html' ) else : ext = self . image_type . value . lower () fn = loc / f ' { name } . { ext } ' fig . savefig ( fn , bbox_inches = 'tight' ) if self . boxes [ self . BS ] . value : df = self . op . summary . drop ([ 'gates' ], axis = 1 ) df . to_csv ( loc / 'budget_summary.csv' , index = False , float_format = lambda n : round ( n , 2 ) ) if self . boxes [ self . BD ] . value : self . op . matrix . to_csv ( loc / 'barrier_details.csv' , index = False , float_format = lambda n : round ( n , 2 ) )","title":"_save_files"},{"location":"gui/#infobox","text":"Bases: Column When the user clicks the Run Optimizer button in the Start panel the GUI displays a message by calling one of the methods in this class. Messages are displayed in the modal dialog area defined by the GUI template. Parameters: template \u2013 the application template (which contains the modal dialog area to use) run_cb \u2013 a callback function to invoke after the user reviews settings and clicks \"Continue\" Source code in src/gui/infobox.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , template , run_cb ): \"\"\" Initialize the module. Arguments: template: the application template (which contains the modal dialog area to use) run_cb: a callback function to invoke after the user reviews settings and clicks \"Continue\" \"\"\" super ( InfoBox , self ) . __init__ () self . template = template self . continue_button = pn . widgets . Button ( name = 'Continue' ) self . continue_button . on_click ( run_cb ) self . cancel_button = pn . widgets . Button ( name = 'Cancel' ) self . cancel_button . on_click ( self . _cancel_cb )","title":"InfoBox"},{"location":"gui/#src.gui.infobox.InfoBox._cancel_cb","text":"Close the dialog when the user clicks the \"Cancel\" button. Source code in src/gui/infobox.py 60 61 62 63 64 def _cancel_cb ( self , _ ): \"\"\" Close the dialog when the user clicks the \"Cancel\" button. \"\"\" self . template . close_modal ()","title":"_cancel_cb"},{"location":"gui/#src.gui.infobox.InfoBox.show_missing","text":"Method called by the OP class when it detects missing parameters (e.g. if the user did not select a region or a target). Source code in src/gui/infobox.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def show_missing ( self , rlist , budget , tlist ): \"\"\" Method called by the OP class when it detects missing parameters (e.g. if the user did not select a region or a target). \"\"\" text = self . missing_params_text if len ( rlist ) == 0 : text += ' * one or more geographic regions \\n ' if not budget : text += ' * a maximum budget \\n ' if len ( tlist ) == 0 : text += ' * one or more targets \\n ' self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'warning' )) self . template . open_modal ()","title":"show_missing"},{"location":"gui/#src.gui.infobox.InfoBox.show_invalid_weights","text":"Method called when weighted targets are being used and one of the text boxes does not have a valid entry (must be a number between 1 and 5). Parameters: w ( list [ str ] ) \u2013 the list of strings read from the text entry widgets Source code in src/gui/infobox.py 82 83 84 85 86 87 88 89 90 91 92 93 def show_invalid_weights ( self , w : list [ str ]): \"\"\" Method called when weighted targets are being used and one of the text boxes does not have a valid entry (must be a number between 1 and 5). Arguments: w: the list of strings read from the text entry widgets \"\"\" text = self . invalid_weights_text . format ( w ) self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'warning' )) self . template . open_modal ()","title":"show_invalid_weights"},{"location":"gui/#src.gui.infobox.InfoBox.show_params","text":"Method called to allow the user to review the optimization parameters read from the various widgets. Displays each parameter and two buttons (\"Cancel\" and \"Continue\"). Parameters: regions \u2013 list of region names budgets \u2013 a tuple with starting budget, increment, and count targets \u2013 list of restoration target names weights \u2013 list of target weights (optional) mapping \u2013 column mappings (optional) Source code in src/gui/infobox.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def show_params ( self , regions , budgets , targets , weights , mapping ): \"\"\" Method called to allow the user to review the optimization parameters read from the various widgets. Displays each parameter and two buttons (\"Cancel\" and \"Continue\"). Arguments: regions: list of region names budgets: a tuple with starting budget, increment, and count targets: list of restoration target names weights: list of target weights (optional) mapping: column mappings (optional) \"\"\" bstart , binc , bcount = budgets fbmax = OP . format_budget_amount ( binc * bcount ) fbstep = OP . format_budget_amount ( binc ) fbstart = OP . format_budget_amount ( bstart ) text = self . preview_message_text text += f ' * Regions: { \", \" . join ( regions ) } \\n\\n ' if bcount > 1 : text += f ' * { bcount } budget levels from { fbstep } up to { fbmax } in increments of { fbstep } \\n\\n ' else : text += f ' * a single budget of { fbstart } \\n\\n ' targets = [ t . split ( ':' )[ - 1 ] for t in targets ] if weights : targets = [ f ' { targets [ i ] } \u2a09 { weights [ i ] } ' for i in range ( len ( targets ))] text += f ' * Targets: { \", \" . join ( targets ) } \\n ' text += f ' * Mapping: { mapping } \\n\\n ' self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'secondary' )) self . append ( pn . Row ( self . cancel_button , self . continue_button )) self . template . open_modal ()","title":"show_params"},{"location":"gui/#src.gui.infobox.InfoBox.show_success","text":"Method called after OptiPass has finished running and the results have been parsed successfully. Source code in src/gui/infobox.py 127 128 129 130 131 132 133 134 def show_success ( self ): \"\"\" Method called after OptiPass has finished running and the results have been parsed successfully. \"\"\" self . clear () self . append ( pn . pane . Alert ( self . success_text , alert_type = 'success' )) self . template . open_modal ()","title":"show_success"},{"location":"gui/#src.gui.infobox.InfoBox.show_fail","text":"Method called if OptiPass failed. Parameters: reason \u2013 string containing the error message Source code in src/gui/infobox.py 136 137 138 139 140 141 142 143 144 145 146 147 148 def show_fail ( self , reason ): \"\"\" Method called if OptiPass failed. Arguments: reason: string containing the error message \"\"\" self . clear () text = self . fail_text . format ( reason ) if str ( reason ) == 'No solution' : text += ' \\n * try increasing the maximum budget' self . append ( pn . pane . Alert ( text , alert_type = 'danger' )) self . template . open_modal ()","title":"show_fail"},{"location":"gui/#outputpane","text":"Bases: Column After OptiPass has completed the last optimization run the GUI creates an instance of this class and saves it in the Output tab of the top level display. (displayed in a tab widget showing one figure at a time), the second part has tables showing data about barriers included in solutions. Parameters: op \u2013 an OPResult object with the optimization parameters and results Source code in src/gui/output.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , op , tgmap ): \"\"\" Format the output from OptiPass. The first part of the panel has a set of ROI curves (displayed in a tab widget showing one figure at a time), the second part has tables showing data about barriers included in solutions. Arguments: op: an OPResult object with the optimization parameters and results \"\"\" super ( OutputPane , self ) . __init__ () self . append ( pn . pane . HTML ( '<h3>Optimization Results</h3>' , styles = header_styles )) self . append ( self . _make_title ( op )) if op . bcount > 1 : self . append ( pn . pane . HTML ( '<h3>ROI Curves</h3>' )) self . append ( self . _make_figures_tab ( op )) self . append ( pn . pane . HTML ( '<h3>Budget Summary</h3>' )) self . gate_count = op . summary . gates . apply ( len ) . sum () if self . gate_count == 0 : self . append ( pn . pane . HTML ( '<i>No barriers selected -- consider increasing the budget</i>' )) else : self . append ( self . _make_budget_table ( op , tgmap )) self . append ( pn . Accordion ( ( 'Barrier Details' , self . _make_gate_table ( op )), stylesheets = [ accordion_style_sheet ], ))","title":"OutputPane"},{"location":"gui/#src.gui.output.OutputPane._make_title","text":"The top section of the output pane is a title showing the optimization parameters. Source code in src/gui/output.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def _make_title ( self , op ): \"\"\" The top section of the output pane is a title showing the optimization parameters. \"\"\" tnames = [ OP . target_frame . loc [ t ] . short for t in op . targets ] if op . weights : tnames = [ f ' { tnames [ i ] } \u2a09 { op . weights [ i ] } ' for i in range ( len ( tnames ))] title = f \"<p><b>Regions:</b> { ', ' . join ( op . regions ) } ;\" title += f \" <b>Targets:</b> { ', ' . join ( tnames ) } ;\" if s := OP . mapping_name : title += f \" <b> { s . capitalize () } :</b> { op . mapping } ;\" if op . bcount > 1 : bmax = op . binc * op . bcount smin = OP . format_budget_amount ( op . binc ) smax = OP . format_budget_amount ( bmax ) title += f \" <b>Budgets:</b> { smin } to { smax } </p>\" else : b = OP . format_budget_amount ( op . bmin ), title += \" <b>Budget:</b> {b} </p>\" return pn . pane . HTML ( title )","title":"_make_title"},{"location":"gui/#src.gui.output.OutputPane._make_figures_tab","text":"Create a Tabs object with one tab for each ROI curve. Source code in src/gui/output.py 70 71 72 73 74 75 76 77 78 79 80 81 def _make_figures_tab ( self , op ): \"\"\" Create a Tabs object with one tab for each ROI curve. \"\"\" tabs = pn . Tabs ( tabs_location = 'left' , stylesheets = [ output_tab_style_sheet ], ) op . make_roi_curves () for p in op . display_figures : tabs . append ( p ) return tabs","title":"_make_figures_tab"},{"location":"gui/#src.gui.output.OutputPane._make_budget_table","text":"Make the table of benefits for each budget. Attach a callback function that is called when the user clicks on a row in the table (the callback updates the map to show gates used in a solution). Source code in src/gui/output.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def _make_budget_table ( self , op , tgmap ): \"\"\" Make the table of benefits for each budget. Attach a callback function that is called when the user clicks on a row in the table (the callback updates the map to show gates used in a solution). \"\"\" df = op . budget_table () formatters = { col : NumberFormatter ( format = '0.0' , text_align = 'center' ) for col in df . columns } formatters [ 'Budget' ] = { 'type' : 'money' , 'symbol' : '$' , 'precision' : 0 } formatters [ '# Barriers' ] = NumberFormatter ( format = '0' , text_align = 'center' ) alignment = { 'Budget' : 'right' , 'Net Gain' : 'center' , '# Barriers' : 'center' } table = pn . widgets . Tabulator ( df , show_index = False , hidden_columns = [ 'gates' ], editors = { c : None for c in df . columns }, text_align = alignment , header_align = { c : 'center' for c in df . columns }, formatters = formatters , selectable = True , configuration = { 'columnDefaults' : { 'headerSort' : False }}, ) self . budget_table = df self . make_dots ( table , op , tgmap ) table . on_click ( self . budget_table_cb ) return table","title":"_make_budget_table"},{"location":"gui/#src.gui.output.OutputPane._make_gate_table","text":"Make a table showing details about gates used in solutions. Source code in src/gui/output.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def _make_gate_table ( self , op ): \"\"\" Make a table showing details about gates used in solutions. \"\"\" formatters = { } alignment = { } df = op . gate_table () df . columns = [ OP . format_budget_amount ( int ( s )) if s . isdigit () else s for s in df . columns ] for col in df . columns : if col . startswith ( '$' ) or col in [ 'Primary' , 'Dominant' ]: formatters [ col ] = { 'type' : 'tickCross' , 'crossElement' : '' } alignment [ col ] = 'center' elif col == 'Cost' : formatters [ col ] = { 'type' : 'money' , 'symbol' : '$' , 'precision' : 0 } alignment [ col ] = 'right' table = pn . widgets . Tabulator ( df , show_index = True , frozen_columns = [ 'ID' ], hidden_columns = [ 'count' ], formatters = formatters , text_align = alignment , configuration = { 'columnDefaults' : { 'headerSort' : False }}, header_align = { c : 'center' for c in df . columns }, selectable = False , ) table . disabled = True self . gate_table = df return table","title":"_make_gate_table"},{"location":"gui/#src.gui.output.OutputPane.make_dots","text":"Called after the output panel is initialized, make a set of glyphs to display for each budget level. Source code in src/gui/output.py 150 151 152 153 154 155 156 157 158 159 160 161 def make_dots ( self , plot , op , tgmap ): \"\"\" Called after the output panel is initialized, make a set of glyphs to display for each budget level. \"\"\" self . selected_row = None self . dots = [] for name , row in self . budget_table . iterrows (): df = tgmap . map_coords () . loc [ row . gates ] c = tgmap . map . circle_dot ( 'x' , 'y' , size = 12 , line_color = 'blue' , fill_color = 'white' , source = df ) c . visible = False self . dots . append ( c )","title":"make_dots"},{"location":"gui/#src.gui.output.OutputPane.budget_table_cb","text":"The callback function invoked when the user clicks a row in the budget table. Use the event to figure out which row was clicked. Hide any dots that were displayed previously, then make the dots for the selected row visible. Source code in src/gui/output.py 163 164 165 166 167 168 169 170 171 172 def budget_table_cb ( self , e ): \"\"\" The callback function invoked when the user clicks a row in the budget table. Use the event to figure out which row was clicked. Hide any dots that were displayed previously, then make the dots for the selected row visible. \"\"\" if n := self . selected_row : self . dots [ n ] . visible = False self . selected_row = e . row self . dots [ self . selected_row ] . visible = True","title":"budget_table_cb"},{"location":"gui/#src.gui.output.OutputPane.hide_dots","text":"Callback function invoked when users click on a region name in the start panel to hide any dots that might be on the map. Source code in src/gui/output.py 174 175 176 177 178 179 180 181 def hide_dots ( self ): \"\"\" Callback function invoked when users click on a region name in the start panel to hide any dots that might be on the map. \"\"\" if self . selected_row : self . dots [ self . selected_row ] . visible = False self . selected_row = None","title":"hide_dots"},{"location":"gui/#regionbox","text":"Bases: Column The region box displays the names of each geographic region in the data set, with a checkbox next to the name. When the user clicks on one of the checkboxes several actions are triggered: the set of selected regions is updated, the budget widget is notified so it can update the maximum budget (based on the total cost of all barriers in the current selection), and the map is updated by zooming in to a level that contains only the barriers in the selected regions. Parameters: map \u2013 the TGMap object that will be updated when regions are selected budget \u2013 the BudgetBox object to update when regions are selected Source code in src/gui/regionbox.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , map , budget ): \"\"\" Create the grid of checkboxes and set up the callback function. Arguments: map: the TGMap object that will be updated when regions are selected budget: the BudgetBox object to update when regions are selected \"\"\" super ( RegionBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . map = map self . budget_box = budget self . boxes = { } for name in OP . region_names : box = pn . widgets . Checkbox ( name = name , styles = box_styles , stylesheets = [ box_style_sheet ]) box . param . watch ( self . cb , [ 'value' ]) self . boxes [ name ] = box self . selected = set () self . external_cb = None self . append ( pn . GridBox ( * self . boxes . values (), ncols = 3 ))","title":"RegionBox"},{"location":"gui/#src.gui.regionbox.RegionBox.cb","text":"Callback function invoked when one of the checkboxes is clicked. If the new state of the checkbox is 'selected' the region is added to the set of selected regions, otherwise it is removed. After updating the set notify the map widget and any other widgets that have been registered as external callbacks. Source code in src/gui/regionbox.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def cb ( self , * events ): \"\"\" Callback function invoked when one of the checkboxes is clicked. If the new state of the checkbox is 'selected' the region is added to the set of selected regions, otherwise it is removed. After updating the set notify the map widget and any other widgets that have been registered as external callbacks. \"\"\" for e in events : if e . type == 'changed' : r = e . obj . name if e . new : self . selected . add ( r ) else : self . selected . remove ( r ) amount = sum ( OP . total_cost [ x ] for x in self . selected ) self . budget_box . set_budget_max ( amount ) self . map . display_regions ( self . selected ) # self.map.zoom(self.selected) if self . external_cb : self . external_cb ()","title":"cb"},{"location":"gui/#src.gui.regionbox.RegionBox.check","text":"Initialize the box by addidng region to the selection. Source code in src/gui/regionbox.py 62 63 64 65 66 def check ( self , region ): \"\"\" Initialize the box by addidng region to the selection. \"\"\" self . boxes [ region ] . value = True","title":"check"},{"location":"gui/#src.gui.regionbox.RegionBox.selection","text":"Return a list of the names of currently selected regions. Source code in src/gui/regionbox.py 68 69 70 71 72 def selection ( self ) -> list [ str ]: \"\"\" Return a list of the names of currently selected regions. \"\"\" return list ( self . selected )","title":"selection"},{"location":"gui/#src.gui.regionbox.RegionBox.add_external_callback","text":"Save a reference to an external function to call when a region box is clicked. Parameters: f \u2013 aditional function to call when a checkbox is clicked Source code in src/gui/regionbox.py 74 75 76 77 78 79 80 81 def add_external_callback ( self , f ): \"\"\" Save a reference to an external function to call when a region box is clicked. Arguments: f: aditional function to call when a checkbox is clicked \"\"\" self . external_cb = f","title":"add_external_callback"},{"location":"gui/#targetbox","text":"Bases: Column The restoration targets are shown in a matrix with a selection widget next to each target name. The TargetBox widget has two tabs showing different types of selection widgets, either simple checkboxes (shown by a BasicTargetBox) or text entry widgets (shown by WeightedTargetBox). Source code in src/gui/targetbox.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self ): super ( TargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) if OP . mapping_name : lst = [ s . capitalize () for s in OP . target_columns ] label = OP . mapping_name . capitalize () self . mapping_buttons = pn . widgets . RadioBoxGroup ( name = label , options = lst ) mapping_box = pn . Column ( pn . pane . HTML ( f '<b> { label } <b>' , align = 'start' ), self . mapping_buttons , ) else : self . mapping_buttons = None self . tabs = pn . Tabs ( ( 'Basic' , BasicTargetBox ()), ( 'Weighted' , WeightedTargetBox ()), ) row = pn . Row () row . append ( self . tabs ) if self . mapping_buttons : row . append ( mapping_box ) self . append ( row )","title":"TargetBox"},{"location":"gui/#src.gui.targetbox.TargetBox.make_layout","text":"Read the target layout (size of grid, location of each target in the grid) Source code in src/gui/targetbox.py 40 41 42 43 44 45 46 47 @staticmethod def make_layout ( obj ): \"\"\" Read the target layout (size of grid, location of each target in the grid) \"\"\" obj . layout = [ s . split () for s in OP . target_layout ] obj . nrows = len ( obj . layout ) obj . ncols = max ( len ( r ) for r in obj . layout )","title":"make_layout"},{"location":"gui/#src.gui.targetbox.TargetBox.selection","text":"Get a list of IDs of selected targets from the current target widget. Source code in src/gui/targetbox.py 49 50 51 52 53 def selection ( self ) -> list [ str ]: \"\"\" Get a list of IDs of selected targets from the current target widget. \"\"\" return self . tabs [ self . tabs . active ] . selection ()","title":"selection"},{"location":"gui/#src.gui.targetbox.TargetBox.weights","text":"Get target weights from the current target widget. Source code in src/gui/targetbox.py 55 56 57 58 59 def weights ( self ): \"\"\" Get target weights from the current target widget. \"\"\" return self . tabs [ self . tabs . active ] . weights ()","title":"weights"},{"location":"gui/#src.gui.targetbox.TargetBox.mapping","text":"If the targets have alternative column name mappings return the selected mapping name Source code in src/gui/targetbox.py 61 62 63 64 65 66 def mapping ( self ): \"\"\" If the targets have alternative column name mappings return the selected mapping name \"\"\" return self . mapping_buttons . value . lower () if OP . mapping_name else None","title":"mapping"},{"location":"gui/#basictargetbox","text":"Bases: Column The BasicTargetBox widget displays a checkbox next to each target name. Source code in src/gui/targetbox.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def __init__ ( self ): \"\"\" Make the grid of checkboxes. The IDs and descriptions of targets are fetched by calling the make_layout function in the Target class. \"\"\" super ( BasicTargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) TargetBox . make_layout ( self ) self . grid = pn . GridBox ( nrows = self . nrows , ncols = self . ncols ) for row in self . layout : for t in row : s = OP . target_frame . loc [ t ] . long b = pn . widgets . Checkbox ( name = s , styles = box_styles , stylesheets = [ box_style_sheet ], tags = [ t ]) self . grid . append ( b ) self . append ( self . grid )","title":"BasicTargetBox"},{"location":"gui/#src.gui.targetbox.BasicTargetBox.selection","text":"Return a list of IDs of selected targets. Source code in src/gui/targetbox.py 91 92 93 94 95 def selection ( self ) -> list [ str ]: \"\"\" Return a list of IDs of selected targets. \"\"\" return [ b . tags [ 0 ] for b in self . grid . objects if b . value ]","title":"selection"},{"location":"gui/#src.gui.targetbox.BasicTargetBox.weights","text":"There are no weights (all targets considered equally) so return an empty list. Source code in src/gui/targetbox.py 102 103 104 105 106 def weights ( self ): \"\"\" There are no weights (all targets considered equally) so return an empty list. \"\"\" return []","title":"weights"},{"location":"gui/#weightedtargetbox","text":"Bases: Column A WeightedTargetBox shows a text entry widget next to each target to allow users to enter a numeric weight for the target. Source code in src/gui/targetbox.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def __init__ ( self ): \"\"\" Make the grid of text entry widgets. The IDs and descriptions of targets are fetched by calling the make_layout function in the Target class. \"\"\" super ( WeightedTargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) TargetBox . make_layout ( self ) self . grid = pn . GridBox ( nrows = self . nrows , ncols = self . ncols ) for row in self . layout : for t in row : s = OP . target_frame . loc [ t ] . long w = pn . Row () w . append ( pn . widgets . TextInput ( name = '' , placeholder = '' , width = 25 , align = 'center' , stylesheets = [ input_style_sheet ], tags = [ t ])) w . append ( pn . pane . HTML ( s )) self . grid . append ( w ) self . append ( self . grid )","title":"WeightedTargetBox"},{"location":"gui/#src.gui.targetbox.WeightedTargetBox.selection","text":"Return a list of IDs of selected targets. Source code in src/gui/targetbox.py 131 132 133 134 135 def selection ( self ) -> list [ str ]: \"\"\" Return a list of IDs of selected targets. \"\"\" return [ w [ 0 ] . tags [ 0 ] for w in self . grid . objects if w [ 0 ] . value ]","title":"selection"},{"location":"gui/#src.gui.targetbox.WeightedTargetBox.weights","text":"Return the text content of each non-empty text entry box. Source code in src/gui/targetbox.py 142 143 144 145 146 def weights ( self ) -> list [ str ]: \"\"\" Return the text content of each non-empty text entry box. \"\"\" return [ w [ 0 ] . value for w in self . grid . objects if w [ 0 ] . value ]","title":"weights"},{"location":"gui/#tgmap","text":"A TGMap object manages the display of a map that shows the locations of the barriers in a project. A static method named init is a factory that instantiates a new map. It will read the \"mapinfo\" file for the project and return a reference to a new map object belonging to the class specified in the mapinfo file. Attributes: map \u2013 a Bokeh figure object, with x and y ranges defined by the locations of the barriers dots \u2013 a dictionary that maps region names to a list of circle glyphs for each barrier in a region ranges \u2013 a data frame that has the range of x and y coordinates for each region","title":"TGMap"},{"location":"gui/#src.gui.tgmap.TGMap.map_coords","text":"Return a frame that has the coordinates and other info needed to display gates on a map Source code in src/gui/tgmap.py 40 41 42 43 44 45 def map_coords ( self ): ''' Return a frame that has the coordinates and other info needed to display gates on a map ''' return self . _map_coords","title":"map_coords"},{"location":"gui/#src.gui.tgmap.TGMap.graphic","text":"Return a reference to the map (a Bokeh figure). Source code in src/gui/tgmap.py 47 48 49 50 51 def graphic ( self ): ''' Return a reference to the map (a Bokeh figure). ''' return self . map","title":"graphic"},{"location":"gui/#src.gui.tgmap.TGMap.display_regions","text":"Method called when the user clicks the checkbox next to the name of a region. Set the visible attribute of each dot to True or False depending on whether the region it is in is selected. Parameters: selection \u2013 a list of names of regions currently selected Source code in src/gui/tgmap.py 53 54 55 56 57 58 59 60 61 62 63 def display_regions ( self , selection ): \"\"\" Method called when the user clicks the checkbox next to the name of a region. Set the visible attribute of each dot to True or False depending on whether the region it is in is selected. Arguments: selection: a list of names of regions currently selected \"\"\" for r , dots in self . dots . items (): dots . visible = r in selection","title":"display_regions"},{"location":"gui/#staticmap","text":"Bases: TGMap A static map is simply a PNG file downloaded from the server. Source code in src/gui/tgmap.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def __init__ ( self ): url = f \" { OP . server_url } /map/ { OP . project_name } / { OP . mapinfo [ 'map_file' ] } \" logging . info ( f 'Fetching map from { url } ' ) xpixels = 473 ypixels = 533 p = bk . figure ( title = OP . mapinfo [ 'map_title' ], x_range = ( 0 , xpixels ), y_range = ( 0 , ypixels ), tools = OP . mapinfo [ 'map_tools' ], tooltips = [ ( \"Barrier\" , \"@ID\" ), ( \"Region\" , \"@region\" ), ( \"Cost\" , \"@cost\" ) ] ) p . image_url ( url = [ url ], x = 0 , y = ypixels , h = ypixels , w = xpixels ) bf = OP . barrier_frame self . dots = { } for r in OP . region_names : df = bf [ bf . region == r ] c = p . circle ( 'X' , 'Y' , size = 10 , color = 'darkslategray' , source = df ) self . dots [ r ] = c c . visible = False self . map = p df = bf [[ 'region' , 'X' , 'Y' ]] df . columns = [ 'region' , 'x' , 'y' ] self . _map_coords = df","title":"StaticMap"},{"location":"gui/#tiledmap","text":"Bases: TGMap A tiled map uses a tile server to fetch the map image. Fetch the main barrier file to get the coordinates and other data for each barrier. Source code in src/gui/tgmap.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self ): # bf = self._fetch_barriers() self . _map_coords = self . _make_info ( OP . barrier_frame ) self . regions = self . _make_region_list () self . ranges = self . _create_ranges () self . tile_provider = get_provider ( xyz . OpenStreetMap . Mapnik ) p = bk . figure ( title = 'Oregon Coast' , height = 900 , width = 400 , x_range = ( self . _map_coords . x . min () * 0.997 , self . _map_coords . x . max () * 1.003 ), y_range = ( self . _map_coords . y . min () * 0.997 , self . _map_coords . y . max () * 1.003 ), x_axis_type = 'mercator' , y_axis_type = 'mercator' , toolbar_location = 'below' , tools = [ 'pan' , 'wheel_zoom' , 'hover' , 'reset' ], tooltips = [ ( \"ID\" , \"@ID\" ), ( \"Region\" , \"@region\" ), ( \"Type\" , \"@type\" ), ] ) p . add_tile ( self . tile_provider ) p . toolbar . autohide = True self . dots = { } for r in self . regions : df = self . _map_coords [ self . _map_coords . region == r ] c = p . circle ( 'x' , 'y' , size = 5 , color = 'darkslategray' , source = df , tags = list ( df . index )) self . dots [ r ] = c c . visible = False self . map = p self . outer_x = ( self . _map_coords . x . min () * 0.997 , self . _map_coords . x . max () * 1.003 ) self . outer_y = ( self . _map_coords . y . min () * 0.997 , self . _map_coords . y . max () * 1.003 )","title":"TiledMap"},{"location":"gui/#src.gui.tgmap.TiledMap._make_info","text":"Hidden method, makes a dataframe with attributes needed to display gates on a map. Map latitude and longitude columns in the input frame to Mercator coordinates, and copy the ID, region and barrier types so they can be displayed as tooltips. Source code in src/gui/tgmap.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def _make_info ( self , bf ): \"\"\" Hidden method, makes a dataframe with attributes needed to display gates on a map. Map latitude and longitude columns in the input frame to Mercator coordinates, and copy the ID, region and barrier types so they can be displayed as tooltips. \"\"\" df = bf [[ 'region' , 'type' ]] R = 6378137.0 map_coords = pd . concat ([ df , np . radians ( bf . X ) * R , np . log ( np . tan ( np . pi / 4 + np . radians ( bf . Y ) / 2 )) * R ], axis = 1 ) map_coords . columns = [ 'region' , 'type' , 'x' , 'y' ] return map_coords","title":"_make_info"},{"location":"gui/#src.gui.tgmap.TiledMap._make_region_list","text":"Hidden method, make a list of unique region names, sorted by latitude, so regions are displayed in order from north to south. Updates the list of names in the OP object. Source code in src/gui/tgmap.py 171 172 173 174 175 176 177 178 179 180 181 def _make_region_list ( self ): ''' Hidden method, make a list of unique region names, sorted by latitude, so regions are displayed in order from north to south. Updates the list of names in the OP object. ''' df = self . _map_coords [[ 'region' , 'y' ]] mf = df . groupby ( 'region' ) . mean ( numeric_only = True ) . sort_values ( by = 'y' , ascending = False ) names = list ( mf . index ) OP . region_names = names return names","title":"_make_region_list"},{"location":"gui/#src.gui.tgmap.TiledMap._create_ranges","text":"Hidden method, called by the constructor to create a Pandas Dataframe containing the range of latitudes and longitudes of the barriers in a project. Source code in src/gui/tgmap.py 183 184 185 186 187 188 189 190 191 192 193 194 195 def _create_ranges ( self ): \"\"\" Hidden method, called by the constructor to create a Pandas Dataframe containing the range of latitudes and longitudes of the barriers in a project. \"\"\" g = self . _map_coords . groupby ( 'region' ) return pd . DataFrame ({ 'x_min' : g . min () . x , 'x_max' : g . max () . x , 'y_min' : g . min () . y , 'y_max' : g . max () . y , })","title":"_create_ranges"},{"location":"gui/#src.gui.tgmap.TiledMap.display_regions","text":"Update the map, setting the x and y range based on the currently selected regions. Parameters: selection \u2013 a list of names of regions currently selected Source code in src/gui/tgmap.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def display_regions ( self , selection ): \"\"\" Update the map, setting the x and y range based on the currently selected regions. Arguments: selection: a list of names of regions currently selected \"\"\" super () . display_regions ( selection ) if len ( selection ) > 0 : xmin = min ([ self . ranges [ 'x_min' ][ r ] for r in selection ]) xmax = max ([ self . ranges [ 'x_max' ][ r ] for r in selection ]) ymin = min ([ self . ranges [ 'y_min' ][ r ] for r in selection ]) ymax = max ([ self . ranges [ 'y_max' ][ r ] for r in selection ]) mx = ( xmax + xmin ) / 2 my = ( ymax + ymin ) / 2 dx = max ( 5000 , xmax - xmin ) dy = max ( 5000 , ymax - ymin ) ar = self . map . height / self . map . width if dy / dx > ar : dx = dy / ar else : dy = dx * ar self . map . x_range . update ( start = mx - dx / 2 - 5000 , end = mx + dx / 2 + 5000 ) self . map . y_range . update ( start = my - dy / 2 , end = my + dy / 2 ) else : self . map . x_range . update ( start = self . outer_x [ 0 ], end = self . outer_x [ 1 ]) self . map . y_range . update ( start = self . outer_y [ 0 ], end = self . outer_y [ 1 ]) self . map . add_tile ( self . tile_provider )","title":"display_regions"},{"location":"modules/","text":"Reference The source code is in a folder named src . Inside that are files for the top level application ( main.py ), a module that serves as the interface to the server ( op.py ), and a folder named gui that has definitions of the components in graphical user interface. src \u251c\u2500\u2500 gui \u2502 \u251c\u2500\u2500 app.py \u2502 \u251c\u2500\u2500 budgets.py \u2502 \u251c\u2500\u2500 infobox.py \u2502 \u251c\u2500\u2500 output.py \u2502 \u251c\u2500\u2500 regionbox.py \u2502 \u251c\u2500\u2500 styles.py \u2502 \u251c\u2500\u2500 targetbox.py \u2502 \u2514\u2500\u2500 tgmap.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 op.py main.py This file has the main entry point called when the program is launched from the command line. It uses argparse to get command line options, initializes the OptiPass interface, creates the Panel application, and starts the application. make_app Instantiate the top level widget. Returns: \u2013 a TideGatesApp object Source code in src/main.py 60 61 62 63 64 65 66 67 68 69 70 def make_app (): \"\"\" Instantiate the top level widget. Returns: a TideGatesApp object \"\"\" return TideGatesApp ( title = 'Tide Gate Optimization' , sidebar_width = 450 , ) start_app Launch the Bokeh server. Source code in src/main.py 72 73 74 75 76 77 78 79 80 81 82 83 def start_app ( port ): \"\"\" Launch the Bokeh server. \"\"\" pn . extension ( design = 'native' ) pn . serve ( { 'tidegates' : make_app }, port = port , verbose = True , autoreload = True , websocket_origin = '*' , ) op.py A class named OP provides an abstract interface to the data for the current project. For example, the \"widgets\" in the GUI call OP methods to get the list of region names or descriptions of restoration targets. The module is essentially a \"singleton object\". It defines a collection of static methods. When the top level application starts it calls a method named setup , which initializes all the data; after that the GUI objects call methods to get values of the data. MetaOP The OP class is actually constructed at runtime by a \"metaclass\". When the application is started, OP has a few methods but no data. The setup method fetches the data from the server and adds it to the OP class. Here's a concrete example of how this is done, using target data, which is stored in a Pandas dataframe. The metaclass, which is named MetaOP, defines a method named target_frame : @property def target_frame(cls): return cls._target_frame That definition defines the name, but that name doesn't refer to any acutal table of values at this point. The setup method includes these lines to fetch the target descriptions from the server, convert those descriptions into a Pandas dataframe, and save the frame: req = f'{server}/targets/{project}' resp = requests.get(req) if resp.status_code != 200: raise OPServerError(resp) dct = resp.json() buf = StringIO(dct['targets']) cls._target_frame = pd.read_csv(buf).set_index('abbrev') The first line creates the URL of the REST request to send to the remote server, the second line sends the request. When the response comes back, the third line makes sure the request succeeded. Lines 4 and 5 create the data frame, and the last line saves it in an internal variable named _target_frame . From this point on, methods in the GUI can access the data by using the expression OP.target_frame . That will call the target_frame method shown above, which accesses the value in the internal variable and returns it to the GUI. Bases: type This metaclass creates the API for the OP class. It defines read-only attributes that can be accessed but not written from outside the OP module. The values of the attributes can only be set when the setup method is called. Note: one attribute (region_names) is writeable. setup ( server , project , tab ) Initialize the connection to the OptiPass server. Connect to the server, get the barrier file and other data for the project, save it in read-only class variables. Raises an exception if the server is not accessible or if the project name is not known to the server. Parameters: server ( str ) \u2013 the URL of an OptiPass REST server project ( str ) \u2013 the name of a data set on the server tab ( int ) \u2013 the tab to show when starting the app Source code in src/op.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def setup ( cls , server : str , project : str , tab : int ): ''' Initialize the connection to the OptiPass server. Connect to the server, get the barrier file and other data for the project, save it in read-only class variables. Raises an exception if the server is not accessible or if the project name is not known to the server. Arguments: server: the URL of an OptiPass REST server project: the name of a data set on the server tab: the tab to show when starting the app ''' logging . info ( f 'Connecting to { server } ' ) req = f ' { server } /projects' logging . info ( f 'request: { req } ' ) resp = requests . get ( req ) if resp . status_code == 502 : raise requests . exceptions . ConnectionError () elif resp . status_code != 200 : raise OPServerError ( resp ) elif project not in resp . json (): raise ValueError ( f 'unknown project: { project } ' ) cls . _server_url = server cls . _project_name = project req = f ' { server } /targets/ { project } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) dct = resp . json () buf = StringIO ( dct [ 'targets' ]) cls . _target_frame = pd . read_csv ( buf ) . set_index ( 'abbrev' ) cls . _target_layout = dct [ 'layout' ] . strip () . split ( ' \\n ' ) req = f ' { server } /colnames/ { project } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) dct = resp . json () cls . _mapping_name = dct [ 'name' ] cls . _target_columns = dct [ 'files' ] req = f ' { server } /mapinfo/ { project } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) cls . _mapinfo = json . loads ( resp . json ()[ 'mapinfo' ]) req = f ' { server } /barriers/ { project } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) buf = StringIO ( resp . json ()[ 'barriers' ]) cls . _barrier_frame = pd . read_csv ( buf ) . set_index ( 'ID' ) total_cost = cls . _barrier_frame [[ 'region' , 'cost' ]] . groupby ( 'region' ) . sum () cls . _region_names = sorted ( list ( total_cost . index )) cls . _total_cost = { r [ 0 ]: r [ 1 ] . cost for r in total_cost . iterrows () } cls . _initial_tab = tab logging . info ( 'setup complete' ) OP Interface to an OptiPass server. The module consists of a set of static methods that manage a single connection (i.e. it's basically a singleton object). url_for_figure ( fn ) staticmethod Return the URL to use to fetch an image from the server. Parameters: fn ( str ) \u2013 the file name of the image Returns: str \u2013 the URL Source code in src/op.py 152 153 154 155 156 157 158 159 160 161 162 163 @staticmethod def url_for_figure ( fn : str ) -> str : ''' Return the URL to use to fetch an image from the server. Arguments: fn: the file name of the image Returns: the URL ''' return f ' { OP . server_url } /static/images/' format_budgets ( cols ) staticmethod Create a dictionary that maps budget values to abbreviated dollar amounts. Parameters: cols ( list [ int ] ) \u2013 the list of budget amounts Returns: dict [ int , str ] \u2013 dictionary Source code in src/op.py 165 166 167 168 169 170 171 172 173 174 175 176 177 @staticmethod def format_budgets ( cols : list [ int ]) -> dict [ int , str ]: ''' Create a dictionary that maps budget values to abbreviated dollar amounts. Arguments: cols: the list of budget amounts Returns: dictionary ''' return { n : OP . format_budget_amount ( n ) for n in cols } format_budget_amount ( n ) staticmethod Convert an integer dollar amount into an abbreviation, e.g. 100000 becomes \"$100K\" and 2500000 becomes \"$2.5M\". Parameters: n ( int ) \u2013 the amount to convert Returns: str \u2013 the abbreviation Source code in src/op.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 @staticmethod def format_budget_amount ( n : int ) -> str : ''' Convert an integer dollar amount into an abbreviation, e.g. 100000 becomes \"$100K\" and 2500000 becomes \"$2.5M\". Arguments: n: the amount to convert Returns: the abbreviation ''' divisor , suffix = OP . dollar_format [ 'mil' ] if n >= 1000000 else OP . dollar_format [ 'thou' ] s = '$ {:} ' . format ( n / divisor ) if s . endswith ( '.0' ): s = s [: - 2 ] return s + suffix fetch_html_file ( fn ) staticmethod Fetch an HTML file from the server. Parameters: fn ( str ) \u2013 the name of the file Returns: str \u2013 the contents of the file, as a single string Source code in src/op.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 @staticmethod def fetch_html_file ( fn : str ) -> str : ''' Fetch an HTML file from the server. Arguments: fn: the name of the file Returns: the contents of the file, as a single string ''' req = f ' { OP . server_url } /html/ { OP . project_name } / { fn } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) return resp . json () run_optimizer ( regions , budgets , targets , weights , mapping ) staticmethod Send a request to the op-server to run OptiPass using settings from the widgets. Parameters: regions ( list [ str ] ) \u2013 a list of geographic regions (river names) to use budgets ( tuple [ str , str ] ) \u2013 a tuple with budget settings (start, increment, count) targets ( list [ str ] ) \u2013 a list of IDs of targets weights ( list [ int ] ) \u2013 a list of target weights mapping ( str | None ) \u2013 the name of a column mapping file for targets Returns: summary \u2013 data frame with one row per budget level matrix \u2013 data frame with one row per barrier Source code in src/op.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @staticmethod def run_optimizer ( regions : list [ str ], budgets : tuple [ str , str ], targets : list [ str ], weights : list [ int ], mapping : str | None , ): ''' Send a request to the op-server to run OptiPass using settings from the widgets. Args: regions: a list of geographic regions (river names) to use budgets: a tuple with budget settings (start, increment, count) targets: a list of IDs of targets weights: a list of target weights mapping: the name of a column mapping file for targets Returns: summary: data frame with one row per budget level matrix: data frame with one row per barrier ''' req = f ' { OP . server_url } /optipass/ { OP . project_name } ' args = { 'regions' : regions , 'budgets' : budgets , 'targets' : targets , 'weights' : weights or None , 'mapping' : [ OP . mapping_name , mapping ], } if token := DevOP . results_dir (): args [ 'tempdir' ] = token resp = requests . get ( req , args ) if resp . status_code != 200 : raise OPServerError ( resp ) dct = resp . json () buf = StringIO ( dct [ 'summary' ]) summary = pd . read_csv ( buf ) buf = StringIO ( dct [ 'matrix' ]) matrix = pd . read_csv ( buf ) . set_index ( 'ID' ) return summary , matrix OPResult The run_optimizer method creates an instance of this class each time the server returns a set of results from an optimization run. Pass the constructor the dictionaries returned by the server and the widget settings (region names, budget levels, target selection) that were passed to run_optimizer . The code that creates the output tab calls methods of this class to make figures and tables displayed in the GUI. Source code in src/op.py 278 279 280 281 282 283 284 285 286 287 288 289 290 def __init__ ( self , regions , budgets , targets , weights , mapping , summary , matrix ): self . summary = pd . DataFrame ( summary ) self . matrix = pd . DataFrame ( matrix ) self . regions = regions self . bmin , self . binc , self . bcount = budgets self . targets = targets self . weights = weights self . mapping = mapping self . display_figures = [] self . download_figures = [] # The 'gates' column is a string, need to convert it to a list self . summary . gates = summary . gates . map ( lambda s : json . loads ( s . replace ( \"'\" , '\"' ))) make_roi_curves () Generate ROI plots based on computed benefits. Source code in src/op.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 def make_roi_curves ( self ): \"\"\" Generate ROI plots based on computed benefits. \"\"\" climate = None subtitle = 'Region: ' if len ( self . regions ) == 1 else 'Regions: ' subtitle += ', ' . join ( self . regions ) for i , t in enumerate ( self . targets ): target = OP . target_frame . loc [ t ] title = target . long if target . infra : title += f ' ( { self . mapping } { OP . mapping_name } )' f = self . bokeh_figure ( self . summary . budget , self . summary [ target . name ], title , subtitle , target . label ) self . display_figures . append (( target . short , f )) f = self . pyplot_figure ( self . summary . budget , self . summary [ target . name ], title , subtitle , target . label ) self . download_figures . append (( target . short , f )) if len ( self . targets ) > 1 : title = 'Combined Potential Benefit' if climate : title += f ' ( { OP . mapping } { OP . mapping_name } )' if self . weights : subtitle += ' \\n Targets:' for i , t in enumerate ( self . targets ): target = OP . target_frame . loc [ t ] subtitle += f ' { target . short } \u2a09 { int ( self . weights [ i ]) } ' f = self . bokeh_figure ( self . summary . budget , self . summary . netgain , title , subtitle , 'Weighted Net Gain' ) self . display_figures . insert ( 0 , ( 'Net' , f )) f = self . pyplot_figure ( self . summary . budget , self . summary . netgain , title , subtitle , 'Weighted Net Gain' ) self . download_figures . insert ( 0 , ( 'Net' , f )) budget_table () Make a table that has one column for each budget level, showing which barriers were included in the solution for that level. Source code in src/op.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def budget_table ( self ): \"\"\" Make a table that has one column for each budget level, showing which barriers were included in the solution for that level. \"\"\" df = self . summary [[ 'budget' , 'gates' ]] colnames = [ 'Budget' , 'gates' ] df = pd . concat ([ df , pd . Series ( self . summary . gates . apply ( len )) ], axis = 1 ) colnames . append ( '# Barriers' ) for i , t in enumerate ( self . targets ): target = OP . target_frame . loc [ t ] if target . name in self . summary . columns : df = pd . concat ([ df , self . summary [ target . name ]], axis = 1 ) col = target . short # if self.weights: # col += f'\u2a09{self.weights[i]}' colnames . append ( col ) df = pd . concat ([ df , self . summary [[ 'wph' , 'netgain' ]] ], axis = 1 ) colnames += [ 'WPH' , 'Net Gain' ] df . columns = colnames return df gate_table () Make a table that has one row per gate with columns that are relevant to the output display Source code in src/op.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def gate_table ( self ): \"\"\" Make a table that has one row per gate with columns that are relevant to the output display \"\"\" filtered = OP . barrier_frame [ OP . barrier_frame . region . isin ( self . regions )] col1 = [ c for c in [ 'region' , 'cost' , 'DSID' , 'type' ] if c in filtered . columns ] budget_cols = [ c for c in self . matrix . columns if c . isnumeric () and c > '0' ] target_cols = [ c for c in self . matrix . columns if len ( c ) == 2 ] col2 = [ c for c in [ 'primary' , 'dominant' , 'X' , 'Y' ] if c in filtered . columns ] df = pd . concat ([ filtered [ col1 ], self . matrix [ budget_cols ], self . matrix [ 'count' ], self . matrix [ target_cols ], filtered [ col2 ] ], axis = 1 ) df = df [ df [ 'count' ] > 0 ] . sort_values ( by = 'count' , ascending = False ) . fillna ( '-' ) df . columns = [ s . capitalize () if s in [ 'region' , 'cost' , 'type' , 'primary' , 'dominant' ] else s for s in df . columns ] return df DevOP A collection of utility functions for developers. If there is an environment variable that defines a value for a widget the code that builds the GUI will put that value in the widget when it is created, e.g. if OPREGIONS is set to \"Coos Umpqua Coquille\" those three regions will be selected in the region box. If OPTMPDIR is defined it should be the path to a directory on the server that has outputs from a previous optimization. The path will be included in the request URL that runs OptiPass. When the server see this it will return the previous results instead of running OptiPass again -- very useful for testing on macOS (which can't run OptiPass). default_list ( varname ) staticmethod Split the value of an environment variable into a list Source code in src/op.py 441 442 443 444 445 446 447 448 @staticmethod def default_list ( varname ): ''' Split the value of an environment variable into a list ''' if lst := os . getenv ( varname ): return lst . split ( ':' ) return [] default_regions () staticmethod Return the value of OPREGIONS Source code in src/op.py 450 451 452 453 454 455 @staticmethod def default_regions (): ''' Return the value of OPREGIONS ''' return DevOP . default_list ( 'OPREGIONS' ) default_budget () staticmethod Return the value of OPBUDGET Source code in src/op.py 457 458 459 460 461 462 @staticmethod def default_budget (): ''' Return the value of OPBUDGET ''' return int ( os . getenv ( 'OPBUDGET' , '0' )) default_targets () staticmethod Return the value of OPTARGETS Source code in src/op.py 464 465 466 467 468 469 @staticmethod def default_targets (): ''' Return the value of OPTARGETS ''' return DevOP . default_list ( 'OPTARGETS' ) results_dir () staticmethod Return the value of OPTMPDIR Source code in src/op.py 471 472 473 474 475 476 @staticmethod def results_dir (): ''' Return the value of OPTMPDIR ''' return os . getenv ( 'OPTMPDIR' )","title":"Reference"},{"location":"modules/#reference","text":"The source code is in a folder named src . Inside that are files for the top level application ( main.py ), a module that serves as the interface to the server ( op.py ), and a folder named gui that has definitions of the components in graphical user interface. src \u251c\u2500\u2500 gui \u2502 \u251c\u2500\u2500 app.py \u2502 \u251c\u2500\u2500 budgets.py \u2502 \u251c\u2500\u2500 infobox.py \u2502 \u251c\u2500\u2500 output.py \u2502 \u251c\u2500\u2500 regionbox.py \u2502 \u251c\u2500\u2500 styles.py \u2502 \u251c\u2500\u2500 targetbox.py \u2502 \u2514\u2500\u2500 tgmap.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 op.py","title":"Reference"},{"location":"modules/#mainpy","text":"This file has the main entry point called when the program is launched from the command line. It uses argparse to get command line options, initializes the OptiPass interface, creates the Panel application, and starts the application.","title":"main.py"},{"location":"modules/#make_app","text":"Instantiate the top level widget. Returns: \u2013 a TideGatesApp object Source code in src/main.py 60 61 62 63 64 65 66 67 68 69 70 def make_app (): \"\"\" Instantiate the top level widget. Returns: a TideGatesApp object \"\"\" return TideGatesApp ( title = 'Tide Gate Optimization' , sidebar_width = 450 , )","title":"make_app"},{"location":"modules/#start_app","text":"Launch the Bokeh server. Source code in src/main.py 72 73 74 75 76 77 78 79 80 81 82 83 def start_app ( port ): \"\"\" Launch the Bokeh server. \"\"\" pn . extension ( design = 'native' ) pn . serve ( { 'tidegates' : make_app }, port = port , verbose = True , autoreload = True , websocket_origin = '*' , )","title":"start_app"},{"location":"modules/#oppy","text":"A class named OP provides an abstract interface to the data for the current project. For example, the \"widgets\" in the GUI call OP methods to get the list of region names or descriptions of restoration targets. The module is essentially a \"singleton object\". It defines a collection of static methods. When the top level application starts it calls a method named setup , which initializes all the data; after that the GUI objects call methods to get values of the data.","title":"op.py"},{"location":"modules/#metaop","text":"The OP class is actually constructed at runtime by a \"metaclass\". When the application is started, OP has a few methods but no data. The setup method fetches the data from the server and adds it to the OP class. Here's a concrete example of how this is done, using target data, which is stored in a Pandas dataframe. The metaclass, which is named MetaOP, defines a method named target_frame : @property def target_frame(cls): return cls._target_frame That definition defines the name, but that name doesn't refer to any acutal table of values at this point. The setup method includes these lines to fetch the target descriptions from the server, convert those descriptions into a Pandas dataframe, and save the frame: req = f'{server}/targets/{project}' resp = requests.get(req) if resp.status_code != 200: raise OPServerError(resp) dct = resp.json() buf = StringIO(dct['targets']) cls._target_frame = pd.read_csv(buf).set_index('abbrev') The first line creates the URL of the REST request to send to the remote server, the second line sends the request. When the response comes back, the third line makes sure the request succeeded. Lines 4 and 5 create the data frame, and the last line saves it in an internal variable named _target_frame . From this point on, methods in the GUI can access the data by using the expression OP.target_frame . That will call the target_frame method shown above, which accesses the value in the internal variable and returns it to the GUI. Bases: type This metaclass creates the API for the OP class. It defines read-only attributes that can be accessed but not written from outside the OP module. The values of the attributes can only be set when the setup method is called. Note: one attribute (region_names) is writeable.","title":"MetaOP"},{"location":"modules/#src.op.MetaOP.setup","text":"Initialize the connection to the OptiPass server. Connect to the server, get the barrier file and other data for the project, save it in read-only class variables. Raises an exception if the server is not accessible or if the project name is not known to the server. Parameters: server ( str ) \u2013 the URL of an OptiPass REST server project ( str ) \u2013 the name of a data set on the server tab ( int ) \u2013 the tab to show when starting the app Source code in src/op.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def setup ( cls , server : str , project : str , tab : int ): ''' Initialize the connection to the OptiPass server. Connect to the server, get the barrier file and other data for the project, save it in read-only class variables. Raises an exception if the server is not accessible or if the project name is not known to the server. Arguments: server: the URL of an OptiPass REST server project: the name of a data set on the server tab: the tab to show when starting the app ''' logging . info ( f 'Connecting to { server } ' ) req = f ' { server } /projects' logging . info ( f 'request: { req } ' ) resp = requests . get ( req ) if resp . status_code == 502 : raise requests . exceptions . ConnectionError () elif resp . status_code != 200 : raise OPServerError ( resp ) elif project not in resp . json (): raise ValueError ( f 'unknown project: { project } ' ) cls . _server_url = server cls . _project_name = project req = f ' { server } /targets/ { project } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) dct = resp . json () buf = StringIO ( dct [ 'targets' ]) cls . _target_frame = pd . read_csv ( buf ) . set_index ( 'abbrev' ) cls . _target_layout = dct [ 'layout' ] . strip () . split ( ' \\n ' ) req = f ' { server } /colnames/ { project } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) dct = resp . json () cls . _mapping_name = dct [ 'name' ] cls . _target_columns = dct [ 'files' ] req = f ' { server } /mapinfo/ { project } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) cls . _mapinfo = json . loads ( resp . json ()[ 'mapinfo' ]) req = f ' { server } /barriers/ { project } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) buf = StringIO ( resp . json ()[ 'barriers' ]) cls . _barrier_frame = pd . read_csv ( buf ) . set_index ( 'ID' ) total_cost = cls . _barrier_frame [[ 'region' , 'cost' ]] . groupby ( 'region' ) . sum () cls . _region_names = sorted ( list ( total_cost . index )) cls . _total_cost = { r [ 0 ]: r [ 1 ] . cost for r in total_cost . iterrows () } cls . _initial_tab = tab logging . info ( 'setup complete' )","title":"setup"},{"location":"modules/#op","text":"Interface to an OptiPass server. The module consists of a set of static methods that manage a single connection (i.e. it's basically a singleton object).","title":"OP"},{"location":"modules/#src.op.OP.url_for_figure","text":"Return the URL to use to fetch an image from the server. Parameters: fn ( str ) \u2013 the file name of the image Returns: str \u2013 the URL Source code in src/op.py 152 153 154 155 156 157 158 159 160 161 162 163 @staticmethod def url_for_figure ( fn : str ) -> str : ''' Return the URL to use to fetch an image from the server. Arguments: fn: the file name of the image Returns: the URL ''' return f ' { OP . server_url } /static/images/'","title":"url_for_figure"},{"location":"modules/#src.op.OP.format_budgets","text":"Create a dictionary that maps budget values to abbreviated dollar amounts. Parameters: cols ( list [ int ] ) \u2013 the list of budget amounts Returns: dict [ int , str ] \u2013 dictionary Source code in src/op.py 165 166 167 168 169 170 171 172 173 174 175 176 177 @staticmethod def format_budgets ( cols : list [ int ]) -> dict [ int , str ]: ''' Create a dictionary that maps budget values to abbreviated dollar amounts. Arguments: cols: the list of budget amounts Returns: dictionary ''' return { n : OP . format_budget_amount ( n ) for n in cols }","title":"format_budgets"},{"location":"modules/#src.op.OP.format_budget_amount","text":"Convert an integer dollar amount into an abbreviation, e.g. 100000 becomes \"$100K\" and 2500000 becomes \"$2.5M\". Parameters: n ( int ) \u2013 the amount to convert Returns: str \u2013 the abbreviation Source code in src/op.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 @staticmethod def format_budget_amount ( n : int ) -> str : ''' Convert an integer dollar amount into an abbreviation, e.g. 100000 becomes \"$100K\" and 2500000 becomes \"$2.5M\". Arguments: n: the amount to convert Returns: the abbreviation ''' divisor , suffix = OP . dollar_format [ 'mil' ] if n >= 1000000 else OP . dollar_format [ 'thou' ] s = '$ {:} ' . format ( n / divisor ) if s . endswith ( '.0' ): s = s [: - 2 ] return s + suffix","title":"format_budget_amount"},{"location":"modules/#src.op.OP.fetch_html_file","text":"Fetch an HTML file from the server. Parameters: fn ( str ) \u2013 the name of the file Returns: str \u2013 the contents of the file, as a single string Source code in src/op.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 @staticmethod def fetch_html_file ( fn : str ) -> str : ''' Fetch an HTML file from the server. Arguments: fn: the name of the file Returns: the contents of the file, as a single string ''' req = f ' { OP . server_url } /html/ { OP . project_name } / { fn } ' resp = requests . get ( req ) if resp . status_code != 200 : raise OPServerError ( resp ) return resp . json ()","title":"fetch_html_file"},{"location":"modules/#src.op.OP.run_optimizer","text":"Send a request to the op-server to run OptiPass using settings from the widgets. Parameters: regions ( list [ str ] ) \u2013 a list of geographic regions (river names) to use budgets ( tuple [ str , str ] ) \u2013 a tuple with budget settings (start, increment, count) targets ( list [ str ] ) \u2013 a list of IDs of targets weights ( list [ int ] ) \u2013 a list of target weights mapping ( str | None ) \u2013 the name of a column mapping file for targets Returns: summary \u2013 data frame with one row per budget level matrix \u2013 data frame with one row per barrier Source code in src/op.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @staticmethod def run_optimizer ( regions : list [ str ], budgets : tuple [ str , str ], targets : list [ str ], weights : list [ int ], mapping : str | None , ): ''' Send a request to the op-server to run OptiPass using settings from the widgets. Args: regions: a list of geographic regions (river names) to use budgets: a tuple with budget settings (start, increment, count) targets: a list of IDs of targets weights: a list of target weights mapping: the name of a column mapping file for targets Returns: summary: data frame with one row per budget level matrix: data frame with one row per barrier ''' req = f ' { OP . server_url } /optipass/ { OP . project_name } ' args = { 'regions' : regions , 'budgets' : budgets , 'targets' : targets , 'weights' : weights or None , 'mapping' : [ OP . mapping_name , mapping ], } if token := DevOP . results_dir (): args [ 'tempdir' ] = token resp = requests . get ( req , args ) if resp . status_code != 200 : raise OPServerError ( resp ) dct = resp . json () buf = StringIO ( dct [ 'summary' ]) summary = pd . read_csv ( buf ) buf = StringIO ( dct [ 'matrix' ]) matrix = pd . read_csv ( buf ) . set_index ( 'ID' ) return summary , matrix","title":"run_optimizer"},{"location":"modules/#opresult","text":"The run_optimizer method creates an instance of this class each time the server returns a set of results from an optimization run. Pass the constructor the dictionaries returned by the server and the widget settings (region names, budget levels, target selection) that were passed to run_optimizer . The code that creates the output tab calls methods of this class to make figures and tables displayed in the GUI. Source code in src/op.py 278 279 280 281 282 283 284 285 286 287 288 289 290 def __init__ ( self , regions , budgets , targets , weights , mapping , summary , matrix ): self . summary = pd . DataFrame ( summary ) self . matrix = pd . DataFrame ( matrix ) self . regions = regions self . bmin , self . binc , self . bcount = budgets self . targets = targets self . weights = weights self . mapping = mapping self . display_figures = [] self . download_figures = [] # The 'gates' column is a string, need to convert it to a list self . summary . gates = summary . gates . map ( lambda s : json . loads ( s . replace ( \"'\" , '\"' )))","title":"OPResult"},{"location":"modules/#src.op.OPResult.make_roi_curves","text":"Generate ROI plots based on computed benefits. Source code in src/op.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 def make_roi_curves ( self ): \"\"\" Generate ROI plots based on computed benefits. \"\"\" climate = None subtitle = 'Region: ' if len ( self . regions ) == 1 else 'Regions: ' subtitle += ', ' . join ( self . regions ) for i , t in enumerate ( self . targets ): target = OP . target_frame . loc [ t ] title = target . long if target . infra : title += f ' ( { self . mapping } { OP . mapping_name } )' f = self . bokeh_figure ( self . summary . budget , self . summary [ target . name ], title , subtitle , target . label ) self . display_figures . append (( target . short , f )) f = self . pyplot_figure ( self . summary . budget , self . summary [ target . name ], title , subtitle , target . label ) self . download_figures . append (( target . short , f )) if len ( self . targets ) > 1 : title = 'Combined Potential Benefit' if climate : title += f ' ( { OP . mapping } { OP . mapping_name } )' if self . weights : subtitle += ' \\n Targets:' for i , t in enumerate ( self . targets ): target = OP . target_frame . loc [ t ] subtitle += f ' { target . short } \u2a09 { int ( self . weights [ i ]) } ' f = self . bokeh_figure ( self . summary . budget , self . summary . netgain , title , subtitle , 'Weighted Net Gain' ) self . display_figures . insert ( 0 , ( 'Net' , f )) f = self . pyplot_figure ( self . summary . budget , self . summary . netgain , title , subtitle , 'Weighted Net Gain' ) self . download_figures . insert ( 0 , ( 'Net' , f ))","title":"make_roi_curves"},{"location":"modules/#src.op.OPResult.budget_table","text":"Make a table that has one column for each budget level, showing which barriers were included in the solution for that level. Source code in src/op.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def budget_table ( self ): \"\"\" Make a table that has one column for each budget level, showing which barriers were included in the solution for that level. \"\"\" df = self . summary [[ 'budget' , 'gates' ]] colnames = [ 'Budget' , 'gates' ] df = pd . concat ([ df , pd . Series ( self . summary . gates . apply ( len )) ], axis = 1 ) colnames . append ( '# Barriers' ) for i , t in enumerate ( self . targets ): target = OP . target_frame . loc [ t ] if target . name in self . summary . columns : df = pd . concat ([ df , self . summary [ target . name ]], axis = 1 ) col = target . short # if self.weights: # col += f'\u2a09{self.weights[i]}' colnames . append ( col ) df = pd . concat ([ df , self . summary [[ 'wph' , 'netgain' ]] ], axis = 1 ) colnames += [ 'WPH' , 'Net Gain' ] df . columns = colnames return df","title":"budget_table"},{"location":"modules/#src.op.OPResult.gate_table","text":"Make a table that has one row per gate with columns that are relevant to the output display Source code in src/op.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def gate_table ( self ): \"\"\" Make a table that has one row per gate with columns that are relevant to the output display \"\"\" filtered = OP . barrier_frame [ OP . barrier_frame . region . isin ( self . regions )] col1 = [ c for c in [ 'region' , 'cost' , 'DSID' , 'type' ] if c in filtered . columns ] budget_cols = [ c for c in self . matrix . columns if c . isnumeric () and c > '0' ] target_cols = [ c for c in self . matrix . columns if len ( c ) == 2 ] col2 = [ c for c in [ 'primary' , 'dominant' , 'X' , 'Y' ] if c in filtered . columns ] df = pd . concat ([ filtered [ col1 ], self . matrix [ budget_cols ], self . matrix [ 'count' ], self . matrix [ target_cols ], filtered [ col2 ] ], axis = 1 ) df = df [ df [ 'count' ] > 0 ] . sort_values ( by = 'count' , ascending = False ) . fillna ( '-' ) df . columns = [ s . capitalize () if s in [ 'region' , 'cost' , 'type' , 'primary' , 'dominant' ] else s for s in df . columns ] return df","title":"gate_table"},{"location":"modules/#devop","text":"A collection of utility functions for developers. If there is an environment variable that defines a value for a widget the code that builds the GUI will put that value in the widget when it is created, e.g. if OPREGIONS is set to \"Coos Umpqua Coquille\" those three regions will be selected in the region box. If OPTMPDIR is defined it should be the path to a directory on the server that has outputs from a previous optimization. The path will be included in the request URL that runs OptiPass. When the server see this it will return the previous results instead of running OptiPass again -- very useful for testing on macOS (which can't run OptiPass).","title":"DevOP"},{"location":"modules/#src.op.DevOP.default_list","text":"Split the value of an environment variable into a list Source code in src/op.py 441 442 443 444 445 446 447 448 @staticmethod def default_list ( varname ): ''' Split the value of an environment variable into a list ''' if lst := os . getenv ( varname ): return lst . split ( ':' ) return []","title":"default_list"},{"location":"modules/#src.op.DevOP.default_regions","text":"Return the value of OPREGIONS Source code in src/op.py 450 451 452 453 454 455 @staticmethod def default_regions (): ''' Return the value of OPREGIONS ''' return DevOP . default_list ( 'OPREGIONS' )","title":"default_regions"},{"location":"modules/#src.op.DevOP.default_budget","text":"Return the value of OPBUDGET Source code in src/op.py 457 458 459 460 461 462 @staticmethod def default_budget (): ''' Return the value of OPBUDGET ''' return int ( os . getenv ( 'OPBUDGET' , '0' ))","title":"default_budget"},{"location":"modules/#src.op.DevOP.default_targets","text":"Return the value of OPTARGETS Source code in src/op.py 464 465 466 467 468 469 @staticmethod def default_targets (): ''' Return the value of OPTARGETS ''' return DevOP . default_list ( 'OPTARGETS' )","title":"default_targets"},{"location":"modules/#src.op.DevOP.results_dir","text":"Return the value of OPTMPDIR Source code in src/op.py 471 472 473 474 475 476 @staticmethod def results_dir (): ''' Return the value of OPTMPDIR ''' return os . getenv ( 'OPTMPDIR' )","title":"results_dir"},{"location":"tests/","text":"Unit Tests Unit testing is done with pytest . To run all the tests, simply cd to the top level directory and type this shell command: $ pytest The tests are all in the tests directory: test_optipass.py has functions that test the interface to OptiPass You can run one set of tests by including the file name in the shell command, e.g. $ pytest test/test_optipass.py Test the OP Class The OP class is the abstract interface to the op-server REST server. When the main application starts it calls the setup method. That method sends HTTP requests to the server and it saves the returned values so they are accessible to static methods of the OP class. To test setup we use a library named responses . It allows us to \"short-circuit\" the HTTP request. Whenever setup tries to send a URL, the responses module catches it and returns a response to use for the test. Here's an example. To get the list of project names from the server, the setup method has this code: req = f'{server}/projects' resp = requests.get(req) In the test, we have this code: path_to_projects = f'{server}/projects' responses.get(path_to_projects, json = [\"demo\"]) What that means is \"whenever there is an HTTP request to a URL of the form f'{server}/projects' reply with the JSON form of the list [\"demo\"] . In other words, trick the setup code into thinking it connected to a server that has the demo data. The body of the test_setup method defines responses for all of the requests that setup will try to send. It then calls setup , and when it returns the test code will check all of the attributes of the OP class to make sure they have the expected values. test_setup ( barriers , targets , layout , mapinfo ) Test the attributes saved by the setup method. Source code in test/test_optipass.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @responses . activate def test_setup ( barriers , targets , layout , mapinfo ): ''' Test the attributes saved by the setup method. ''' server = 'http://localhost:8000' path_to_projects = f ' { server } /projects' responses . get ( path_to_projects , json = [ \"demo\" ]) with open ( barriers ) as f : path_to_barriers = f ' { server } /barriers/demo' responses . get ( path_to_barriers , json = { \"project\" : \"demo\" , \"barriers\" : f . read ()}) with open ( targets ) as f : target_csv = f . read () with open ( layout ) as f : target_layout = f . read () path_to_targets = f ' { server } /targets/demo' responses . get ( path_to_targets , json = { \"project\" : \"demo\" , \"targets\" : target_csv , \"layout\" : target_layout }) path_to_colnames = f ' { server } /colnames/demo' responses . get ( path_to_colnames , json = { \"name\" : None , \"files\" :[ \"colnames.csv\" ]}) with open ( mapinfo ) as f : path_to_mapinfo = f ' { server } /mapinfo/demo' responses . get ( path_to_mapinfo , json = { \"project\" : \"demo\" , \"mapinfo\" : f . read ()}) OP . setup ( server , 'demo' , 1 ) assert OP . server_url == 'http://localhost:8000' assert OP . project_name == 'demo' assert OP . initial_tab == 1 assert len ( OP . target_frame ) == 2 assert list ( OP . target_frame . columns ) == [ 'long' , 'short' , 'label' , 'infra' ] assert list ( OP . target_frame . index ) == [ 'T1' , 'T2' ] assert OP . target_layout == [ 'T1 T2' ] assert OP . mapping_name is None assert OP . target_columns == [ 'colnames.csv' ] assert OP . mapinfo [ 'map_type' ] == 'StaticMap' assert OP . mapinfo [ 'map_file' ] == 'Riverlands.png' assert OP . mapinfo [ 'map_title' ] == 'The Riverlands' assert OP . region_names == [ 'Red Fork' , 'Trident' ] assert len ( OP . barrier_frame ) == 6 assert list ( OP . barrier_frame . index ) == list ( 'ABCDEF' ) assert len ( OP . barrier_frame . columns ) == 8 assert round ( OP . barrier_frame . cost . sum ()) == 590000 assert sorted ( OP . total_cost . keys ()) == OP . region_names assert round ( sum ( OP . total_cost . values ())) == round ( OP . barrier_frame . cost . sum ()) with pytest . raises ( AttributeError ) as err : OP . initial_tab = 2 assert 'no setter' in str ( err ) Widget Tests TBD","title":"Tests"},{"location":"tests/#unit-tests","text":"Unit testing is done with pytest . To run all the tests, simply cd to the top level directory and type this shell command: $ pytest The tests are all in the tests directory: test_optipass.py has functions that test the interface to OptiPass You can run one set of tests by including the file name in the shell command, e.g. $ pytest test/test_optipass.py","title":"Unit Tests"},{"location":"tests/#test-the-op-class","text":"The OP class is the abstract interface to the op-server REST server. When the main application starts it calls the setup method. That method sends HTTP requests to the server and it saves the returned values so they are accessible to static methods of the OP class. To test setup we use a library named responses . It allows us to \"short-circuit\" the HTTP request. Whenever setup tries to send a URL, the responses module catches it and returns a response to use for the test. Here's an example. To get the list of project names from the server, the setup method has this code: req = f'{server}/projects' resp = requests.get(req) In the test, we have this code: path_to_projects = f'{server}/projects' responses.get(path_to_projects, json = [\"demo\"]) What that means is \"whenever there is an HTTP request to a URL of the form f'{server}/projects' reply with the JSON form of the list [\"demo\"] . In other words, trick the setup code into thinking it connected to a server that has the demo data. The body of the test_setup method defines responses for all of the requests that setup will try to send. It then calls setup , and when it returns the test code will check all of the attributes of the OP class to make sure they have the expected values.","title":"Test the OP Class"},{"location":"tests/#test.test_optipass.test_setup","text":"Test the attributes saved by the setup method. Source code in test/test_optipass.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @responses . activate def test_setup ( barriers , targets , layout , mapinfo ): ''' Test the attributes saved by the setup method. ''' server = 'http://localhost:8000' path_to_projects = f ' { server } /projects' responses . get ( path_to_projects , json = [ \"demo\" ]) with open ( barriers ) as f : path_to_barriers = f ' { server } /barriers/demo' responses . get ( path_to_barriers , json = { \"project\" : \"demo\" , \"barriers\" : f . read ()}) with open ( targets ) as f : target_csv = f . read () with open ( layout ) as f : target_layout = f . read () path_to_targets = f ' { server } /targets/demo' responses . get ( path_to_targets , json = { \"project\" : \"demo\" , \"targets\" : target_csv , \"layout\" : target_layout }) path_to_colnames = f ' { server } /colnames/demo' responses . get ( path_to_colnames , json = { \"name\" : None , \"files\" :[ \"colnames.csv\" ]}) with open ( mapinfo ) as f : path_to_mapinfo = f ' { server } /mapinfo/demo' responses . get ( path_to_mapinfo , json = { \"project\" : \"demo\" , \"mapinfo\" : f . read ()}) OP . setup ( server , 'demo' , 1 ) assert OP . server_url == 'http://localhost:8000' assert OP . project_name == 'demo' assert OP . initial_tab == 1 assert len ( OP . target_frame ) == 2 assert list ( OP . target_frame . columns ) == [ 'long' , 'short' , 'label' , 'infra' ] assert list ( OP . target_frame . index ) == [ 'T1' , 'T2' ] assert OP . target_layout == [ 'T1 T2' ] assert OP . mapping_name is None assert OP . target_columns == [ 'colnames.csv' ] assert OP . mapinfo [ 'map_type' ] == 'StaticMap' assert OP . mapinfo [ 'map_file' ] == 'Riverlands.png' assert OP . mapinfo [ 'map_title' ] == 'The Riverlands' assert OP . region_names == [ 'Red Fork' , 'Trident' ] assert len ( OP . barrier_frame ) == 6 assert list ( OP . barrier_frame . index ) == list ( 'ABCDEF' ) assert len ( OP . barrier_frame . columns ) == 8 assert round ( OP . barrier_frame . cost . sum ()) == 590000 assert sorted ( OP . total_cost . keys ()) == OP . region_names assert round ( sum ( OP . total_cost . values ())) == round ( OP . barrier_frame . cost . sum ()) with pytest . raises ( AttributeError ) as err : OP . initial_tab = 2 assert 'no setter' in str ( err )","title":"test_setup"},{"location":"tests/#widget-tests","text":"TBD","title":"Widget Tests"}]}