{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Web App for OptiPass\u2122 The Migratory Fish Passage Optimization Tool (OptiPass), is an application developed by Jesse O'Hanley at Ecotelligence\u00ae LLC . The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed a REST server named op-server that runs on a Windows VM and acts as an abstract interface to OptiPass . op-client is a web application the provides a graphical user interface to op-server . It can be set up to run on any Linux, macOS, or Windows host. A user just has to start a web browser and point it to the client. Running OptiPass is simply a matter of setting optimization parameters using familar GUI elements like buttons and sliders and then clicking a \"run\" button. Outputs are display in charts and tables in the browser, and can be downloaded for later use offline. Demo The screenshot below shows the graphical user interface. In this example, the client has connected to a server and requested data from the \"demo\" project. This is a small data set from the OptiPass User Manual. It has six tide gates, named A through F. B and C are on the Red Fork river, the rest are on the Trident River. The example in the User Manual does not give names to the rivers. The names and map shown here are from an imaginary territory. We gave the rivers names in order to show how the GUI works. To set up an optimazation run, the user clicks next to river names, which shows the locations of the gates on the map. In this screenshot both rivers are selected so all six gates are highlighted. The user then chooses budget levels. In this case, OptiPass will run five times, with budgets ranging from $100,000 to $500,000. The last step is to choose optimization targets. In this case the user has decided target T1 should be given three times as much weight as T2. When the Run Optimizer button is clicked the client sends these settings to a remote server that is running the op-server software. That will be a Windows system that has OptiPass installed. After OptiPass has completed all five optimizations the results are collected and sent back to the client. The client presents the results as a set of ROI (return-on-investment) curves: Below the graphs are tables that show details of the optimization calculation: Deployment Scenarios There are three ways to set up a client. Each approach is outlined briefly here. Below that is a discussion of the pros and cons of each approach. If you decide you want to use on of the methods to set up your own client you can find detailed instructions in the Deployment section. Option 1: Install Locally The first option is to install the code on your own computer. This process if very similar to the steps used to install Jupyter and use it to edit IPython notebooks. The op-client software is written in Python and uses a library named Panel to display the graphical user interface. Once installed, open a terminal window and type a command that runs the Python program. Python creates a small special-purpose web server (named Bokeh), then you open a browser on your system and connect to the Bokeh server. Option 2: Docker Container This option is similar to Option 1, in that the client software will run on your computer. The difference is that you do not install any Python code. Instead, download (\"pull\") a Docker image from DockerHub. It will have all the code preinstalled in a self-contained Linux system. Then all you need to do is launch a container based on this image. A Bokeh server will be running inside the container. To use the client open a web browser and connect to the server. Option 3: Container at a Cloud Service This option is just like Option 2, except now the container is running at Amazon Web Services (AWS) or some other cloud computing environment. Setting up a new server based on a Docker image is very straightforward. For example, AWS has a service called Lightsail. You simply log in, choose some settings based on the level of service you want (based on how much traffic you expect), give it the name of the Docker image, and AWS does the rest. You can also associate a domain name with your new container so that other users can connect to your client. For example, if you own the domain tidegates-r-us.org you can set it up so it refers to your service at AWS and then other users can point their browswers to https://tidegates-r-us.org . Comparing Scenarios Which scenario is best depends on who will be using the client and what their goals are. Software Developer If you want to download the software to see how it works and perhaps adapt it for your own use Option 1 is best. You probably already have Python installed and are familiar with installing libraries with Pip so installing op-client will be very straightforward. Data Scientist If you want to use the client yourself but don't expect to dig into the source code consider Option 1 or 2. If you have Docker on your system already then Option 2 is clearly the easiest approach. If you don't have Docker, consider installing it. Docker is widely used in data science and odds are you will encounter other projects that are distributed as Docker images. Installing Docker is straightforward. There is a little learning curve the first time you use it, but overall the process is not much more complicated than installing a new Python library. Project Administrator If you want to configure an OptiPass server with data for your project and an OptiPass client that will let other project members or stakeholders access the server then Option 3 is your best choice. You could try Option 1 or Option 2, but it would mean (a) setting up a server on a system within your organization that everyone can access and (b) either installing Python and the client software or Docker on every other group member's system. It may take some initial effort to create an account at AWS and work through the process of launching a new service but in the end it will be far easier for other group members.","title":"A Web App for OptiPass\u2122"},{"location":"#a-web-app-for-optipasstm","text":"The Migratory Fish Passage Optimization Tool (OptiPass), is an application developed by Jesse O'Hanley at Ecotelligence\u00ae LLC . The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed a REST server named op-server that runs on a Windows VM and acts as an abstract interface to OptiPass . op-client is a web application the provides a graphical user interface to op-server . It can be set up to run on any Linux, macOS, or Windows host. A user just has to start a web browser and point it to the client. Running OptiPass is simply a matter of setting optimization parameters using familar GUI elements like buttons and sliders and then clicking a \"run\" button. Outputs are display in charts and tables in the browser, and can be downloaded for later use offline.","title":"A Web App for OptiPass\u2122"},{"location":"#demo","text":"The screenshot below shows the graphical user interface. In this example, the client has connected to a server and requested data from the \"demo\" project. This is a small data set from the OptiPass User Manual. It has six tide gates, named A through F. B and C are on the Red Fork river, the rest are on the Trident River. The example in the User Manual does not give names to the rivers. The names and map shown here are from an imaginary territory. We gave the rivers names in order to show how the GUI works. To set up an optimazation run, the user clicks next to river names, which shows the locations of the gates on the map. In this screenshot both rivers are selected so all six gates are highlighted. The user then chooses budget levels. In this case, OptiPass will run five times, with budgets ranging from $100,000 to $500,000. The last step is to choose optimization targets. In this case the user has decided target T1 should be given three times as much weight as T2. When the Run Optimizer button is clicked the client sends these settings to a remote server that is running the op-server software. That will be a Windows system that has OptiPass installed. After OptiPass has completed all five optimizations the results are collected and sent back to the client. The client presents the results as a set of ROI (return-on-investment) curves: Below the graphs are tables that show details of the optimization calculation:","title":"Demo"},{"location":"#deployment-scenarios","text":"There are three ways to set up a client. Each approach is outlined briefly here. Below that is a discussion of the pros and cons of each approach. If you decide you want to use on of the methods to set up your own client you can find detailed instructions in the Deployment section.","title":"Deployment Scenarios"},{"location":"#option-1-install-locally","text":"The first option is to install the code on your own computer. This process if very similar to the steps used to install Jupyter and use it to edit IPython notebooks. The op-client software is written in Python and uses a library named Panel to display the graphical user interface. Once installed, open a terminal window and type a command that runs the Python program. Python creates a small special-purpose web server (named Bokeh), then you open a browser on your system and connect to the Bokeh server.","title":"Option 1: Install Locally"},{"location":"#option-2-docker-container","text":"This option is similar to Option 1, in that the client software will run on your computer. The difference is that you do not install any Python code. Instead, download (\"pull\") a Docker image from DockerHub. It will have all the code preinstalled in a self-contained Linux system. Then all you need to do is launch a container based on this image. A Bokeh server will be running inside the container. To use the client open a web browser and connect to the server.","title":"Option 2: Docker Container"},{"location":"#option-3-container-at-a-cloud-service","text":"This option is just like Option 2, except now the container is running at Amazon Web Services (AWS) or some other cloud computing environment. Setting up a new server based on a Docker image is very straightforward. For example, AWS has a service called Lightsail. You simply log in, choose some settings based on the level of service you want (based on how much traffic you expect), give it the name of the Docker image, and AWS does the rest. You can also associate a domain name with your new container so that other users can connect to your client. For example, if you own the domain tidegates-r-us.org you can set it up so it refers to your service at AWS and then other users can point their browswers to https://tidegates-r-us.org .","title":"Option 3: Container at a Cloud Service"},{"location":"#comparing-scenarios","text":"Which scenario is best depends on who will be using the client and what their goals are.","title":"Comparing Scenarios"},{"location":"#software-developer","text":"If you want to download the software to see how it works and perhaps adapt it for your own use Option 1 is best. You probably already have Python installed and are familiar with installing libraries with Pip so installing op-client will be very straightforward.","title":"Software Developer"},{"location":"#data-scientist","text":"If you want to use the client yourself but don't expect to dig into the source code consider Option 1 or 2. If you have Docker on your system already then Option 2 is clearly the easiest approach. If you don't have Docker, consider installing it. Docker is widely used in data science and odds are you will encounter other projects that are distributed as Docker images. Installing Docker is straightforward. There is a little learning curve the first time you use it, but overall the process is not much more complicated than installing a new Python library.","title":"Data Scientist"},{"location":"#project-administrator","text":"If you want to configure an OptiPass server with data for your project and an OptiPass client that will let other project members or stakeholders access the server then Option 3 is your best choice. You could try Option 1 or Option 2, but it would mean (a) setting up a server on a system within your organization that everyone can access and (b) either installing Python and the client software or Docker on every other group member's system. It may take some initial effort to create an account at AWS and work through the process of launching a new service but in the end it will be far easier for other group members.","title":"Project Administrator"},{"location":"deploy/","text":"Deploying a Client Local Similar to Jupyter Install using Pip Start from command line. App opens web browser that communicates with remote server. Picture. Local Container Similar to first approach, but if Docker installed, requires no new software. Picture. Container in the Cloud More work for admin to set it up, but then users/customers connect to remote container, have to do nothing.","title":"Deploying a Client"},{"location":"deploy/#deploying-a-client","text":"","title":"Deploying a Client"},{"location":"deploy/#local","text":"Similar to Jupyter Install using Pip Start from command line. App opens web browser that communicates with remote server. Picture.","title":"Local"},{"location":"deploy/#local-container","text":"Similar to first approach, but if Docker installed, requires no new software. Picture.","title":"Local Container"},{"location":"deploy/#container-in-the-cloud","text":"More work for admin to set it up, but then users/customers connect to remote container, have to do nothing.","title":"Container in the Cloud"},{"location":"modules/","text":"Modules The source code is in a folder named src ... src \u251c\u2500\u2500 gui \u2502 \u251c\u2500\u2500 app.py \u2502 \u251c\u2500\u2500 budgets.py \u2502 \u251c\u2500\u2500 infobox.py \u2502 \u251c\u2500\u2500 output.py \u2502 \u251c\u2500\u2500 regionbox.py \u2502 \u251c\u2500\u2500 styles.py \u2502 \u251c\u2500\u2500 targetbox.py \u2502 \u2514\u2500\u2500 tgmap.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 op.py main.py make_app Instantiate the top level widget. Returns: \u2013 a TideGatesApp object Source code in src/main.py 60 61 62 63 64 65 66 67 68 69 70 def make_app (): \"\"\" Instantiate the top level widget. Returns: a TideGatesApp object \"\"\" return TideGatesApp ( title = 'Tide Gate Optimization' , sidebar_width = 450 , ) start_app Launch the Bokeh server. Source code in src/main.py 72 73 74 75 76 77 78 79 80 81 82 83 def start_app ( port ): \"\"\" Launch the Bokeh server. \"\"\" pn . extension ( design = 'native' ) pn . serve ( { 'tidegates' : make_app }, port = port , verbose = True , autoreload = True , websocket_origin = '*' , )","title":"Modules"},{"location":"modules/#modules","text":"The source code is in a folder named src ... src \u251c\u2500\u2500 gui \u2502 \u251c\u2500\u2500 app.py \u2502 \u251c\u2500\u2500 budgets.py \u2502 \u251c\u2500\u2500 infobox.py \u2502 \u251c\u2500\u2500 output.py \u2502 \u251c\u2500\u2500 regionbox.py \u2502 \u251c\u2500\u2500 styles.py \u2502 \u251c\u2500\u2500 targetbox.py \u2502 \u2514\u2500\u2500 tgmap.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 op.py","title":"Modules"},{"location":"modules/#mainpy","text":"","title":"main.py"},{"location":"modules/#make_app","text":"Instantiate the top level widget. Returns: \u2013 a TideGatesApp object Source code in src/main.py 60 61 62 63 64 65 66 67 68 69 70 def make_app (): \"\"\" Instantiate the top level widget. Returns: a TideGatesApp object \"\"\" return TideGatesApp ( title = 'Tide Gate Optimization' , sidebar_width = 450 , )","title":"make_app"},{"location":"modules/#start_app","text":"Launch the Bokeh server. Source code in src/main.py 72 73 74 75 76 77 78 79 80 81 82 83 def start_app ( port ): \"\"\" Launch the Bokeh server. \"\"\" pn . extension ( design = 'native' ) pn . serve ( { 'tidegates' : make_app }, port = port , verbose = True , autoreload = True , websocket_origin = '*' , )","title":"start_app"},{"location":"tests/","text":"Unit Tests Unit testing is done with pytest . To run all the tests, simply cd to the top level directory and type this shell command: $ pytest The tests are all in the tests directory: test_optipass.py has functions that test the interface to OptiPass You can run one set of tests by including the file name in the shell command, e.g. $ pytest test/test_optipass.py Tests for optipass,py test_setup ( barriers , targets , layout , mapinfo ) Test the attributes saved by the setup method. Source code in test/test_optipass.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @responses . activate def test_setup ( barriers , targets , layout , mapinfo ): ''' Test the attributes saved by the setup method. ''' server = 'http://localhost:8000' path_to_projects = f ' { server } /projects' responses . get ( path_to_projects , json = [ \"demo\" ]) with open ( barriers ) as f : path_to_barriers = f ' { server } /barriers/demo' responses . get ( path_to_barriers , json = { \"project\" : \"demo\" , \"barriers\" : f . read ()}) with open ( targets ) as f : target_csv = f . read () with open ( layout ) as f : target_layout = f . read () path_to_targets = f ' { server } /targets/demo' responses . get ( path_to_targets , json = { \"project\" : \"demo\" , \"targets\" : target_csv , \"layout\" : target_layout }) path_to_colnames = f ' { server } /colnames/demo' responses . get ( path_to_colnames , json = { \"name\" : None , \"files\" :[ \"colnames.csv\" ]}) with open ( mapinfo ) as f : path_to_mapinfo = f ' { server } /mapinfo/demo' responses . get ( path_to_mapinfo , json = { \"project\" : \"demo\" , \"mapinfo\" : f . read ()}) OP . setup ( server , 'demo' , 1 ) assert OP . server_url == 'http://localhost:8000' assert OP . project_name == 'demo' assert OP . initial_tab == 1 assert len ( OP . target_frame ) == 2 assert list ( OP . target_frame . columns ) == [ 'long' , 'short' , 'label' , 'infra' ] assert list ( OP . target_frame . index ) == [ 'T1' , 'T2' ] assert OP . target_layout == [ 'T1 T2' ] assert OP . mapping_name is None assert OP . target_columns == [ 'colnames.csv' ] assert OP . mapinfo [ 'map_type' ] == 'StaticMap' assert OP . mapinfo [ 'map_file' ] == 'Riverlands.png' assert OP . mapinfo [ 'map_title' ] == 'The Riverlands' assert OP . region_names == [ 'Red Fork' , 'Trident' ] assert len ( OP . barrier_frame ) == 6 assert list ( OP . barrier_frame . index ) == list ( 'ABCDEF' ) assert len ( OP . barrier_frame . columns ) == 8 assert round ( OP . barrier_frame . cost . sum ()) == 590000 assert sorted ( OP . total_cost . keys ()) == OP . region_names assert round ( sum ( OP . total_cost . values ())) == round ( OP . barrier_frame . cost . sum ()) with pytest . raises ( AttributeError ) as err : OP . initial_tab = 2 assert 'no setter' in str ( err )","title":"Tests"},{"location":"tests/#unit-tests","text":"Unit testing is done with pytest . To run all the tests, simply cd to the top level directory and type this shell command: $ pytest The tests are all in the tests directory: test_optipass.py has functions that test the interface to OptiPass You can run one set of tests by including the file name in the shell command, e.g. $ pytest test/test_optipass.py","title":"Unit Tests"},{"location":"tests/#tests-for-optipasspy","text":"","title":"Tests for optipass,py"},{"location":"tests/#test.test_optipass.test_setup","text":"Test the attributes saved by the setup method. Source code in test/test_optipass.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @responses . activate def test_setup ( barriers , targets , layout , mapinfo ): ''' Test the attributes saved by the setup method. ''' server = 'http://localhost:8000' path_to_projects = f ' { server } /projects' responses . get ( path_to_projects , json = [ \"demo\" ]) with open ( barriers ) as f : path_to_barriers = f ' { server } /barriers/demo' responses . get ( path_to_barriers , json = { \"project\" : \"demo\" , \"barriers\" : f . read ()}) with open ( targets ) as f : target_csv = f . read () with open ( layout ) as f : target_layout = f . read () path_to_targets = f ' { server } /targets/demo' responses . get ( path_to_targets , json = { \"project\" : \"demo\" , \"targets\" : target_csv , \"layout\" : target_layout }) path_to_colnames = f ' { server } /colnames/demo' responses . get ( path_to_colnames , json = { \"name\" : None , \"files\" :[ \"colnames.csv\" ]}) with open ( mapinfo ) as f : path_to_mapinfo = f ' { server } /mapinfo/demo' responses . get ( path_to_mapinfo , json = { \"project\" : \"demo\" , \"mapinfo\" : f . read ()}) OP . setup ( server , 'demo' , 1 ) assert OP . server_url == 'http://localhost:8000' assert OP . project_name == 'demo' assert OP . initial_tab == 1 assert len ( OP . target_frame ) == 2 assert list ( OP . target_frame . columns ) == [ 'long' , 'short' , 'label' , 'infra' ] assert list ( OP . target_frame . index ) == [ 'T1' , 'T2' ] assert OP . target_layout == [ 'T1 T2' ] assert OP . mapping_name is None assert OP . target_columns == [ 'colnames.csv' ] assert OP . mapinfo [ 'map_type' ] == 'StaticMap' assert OP . mapinfo [ 'map_file' ] == 'Riverlands.png' assert OP . mapinfo [ 'map_title' ] == 'The Riverlands' assert OP . region_names == [ 'Red Fork' , 'Trident' ] assert len ( OP . barrier_frame ) == 6 assert list ( OP . barrier_frame . index ) == list ( 'ABCDEF' ) assert len ( OP . barrier_frame . columns ) == 8 assert round ( OP . barrier_frame . cost . sum ()) == 590000 assert sorted ( OP . total_cost . keys ()) == OP . region_names assert round ( sum ( OP . total_cost . values ())) == round ( OP . barrier_frame . cost . sum ()) with pytest . raises ( AttributeError ) as err : OP . initial_tab = 2 assert 'no setter' in str ( err )","title":"test_setup"}]}